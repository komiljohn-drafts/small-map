{"ast":null,"code":"/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { create as createTransform } from '../transform.js';\nimport { equals, getCenter, getHeight, getWidth } from '../extent.js';\nimport { getUid } from '../util.js';\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = new ImageData(new Uint8ClampedArray(buffers[b]), width, height);\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n  const lines = lib.concat(['const __minion__ = (' + createMinion.toString() + ')(', config.operation.toString(), ');', 'self.addEventListener(\"message\", function(event) {', '  const buffer = __minion__(event.data);', '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);', '});']);\n  const worker = new Worker(typeof Blob === 'undefined' ? 'data:text/javascript;base64,' + Buffer.from(lines.join('\\n'), 'binary').toString('base64') : URL.createObjectURL(new Blob(lines, {\n    type: 'text/javascript'\n  })));\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({\n          data: {\n            buffer: minion(data),\n            meta: data['meta']\n          }\n        });\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    }\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.imageOps_ = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this.imageOps_) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this.onWorkerMessage_.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(config, this.onWorkerMessage_.bind(this, 0));\n    }\n    /**\n     * @type {Array<Worker>}\n     * @private\n     */\n    this.workers_ = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this.queue_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxQueueLength_ = config.queue || Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.running_ = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this.dataLookup_ = {};\n\n    /**\n     * @type {Job|null}\n     * @private\n     */\n    this.job_ = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this.enqueue_({\n      inputs: inputs,\n      meta: meta,\n      callback: callback\n    });\n    this.dispatch_();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  enqueue_(job) {\n    this.queue_.push(job);\n    while (this.queue_.length > this.maxQueueLength_) {\n      this.queue_.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  dispatch_() {\n    if (this.running_ || this.queue_.length === 0) {\n      return;\n    }\n    const job = this.queue_.shift();\n    this.job_ = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this.workers_.length;\n    this.running_ = threads;\n    if (threads === 1) {\n      this.workers_[0].postMessage({\n        buffers: buffers,\n        meta: job.meta,\n        imageOps: this.imageOps_,\n        width: width,\n        height: height\n      }, buffers);\n      return;\n    }\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this.workers_[i].postMessage({\n        buffers: slices,\n        meta: job.meta,\n        imageOps: this.imageOps_,\n        width: width,\n        height: height\n      }, slices);\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  onWorkerMessage_(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this.dataLookup_[index] = event.data;\n    --this.running_;\n    if (this.running_ === 0) {\n      this.resolveJob_();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  resolveJob_() {\n    const job = this.job_;\n    const threads = this.workers_.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this.dataLookup_[0]['buffer']);\n      meta = this.dataLookup_[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this.dataLookup_[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this.dataLookup_[i]['meta'];\n      }\n    }\n    this.job_ = null;\n    this.dataLookup_ = {};\n    job.callback(null, new ImageData(data, job.inputs[0].width, job.inputs[0].height), meta);\n    this.dispatch_();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   * @override\n   */\n  disposeInternal() {\n    for (let i = 0; i < this.workers_.length; ++i) {\n      this.workers_[i].terminate();\n    }\n    this.workers_.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations'\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ = options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     * @private\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutter: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: (/** @type {import(\"../View.js\").State} */{\n        rotation: 0\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {}\n    };\n    this.setAttributions(function (frameState) {\n      /** @type {Array<string>} */\n      const attributions = [];\n      for (let i = 0, iMax = options.sources.length; i < iMax; ++i) {\n        const sourceOrLayer = options.sources[i];\n        const source = sourceOrLayer instanceof Source ? sourceOrLayer : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const sourceAttributions = source.getAttributions()?.(frameState);\n        if (typeof sourceAttributions === 'string') {\n          attributions.push(sourceAttributions);\n        } else if (sourceAttributions !== undefined) {\n          attributions.push(...sourceAttributions);\n        }\n      }\n      return attributions;\n    });\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */\n    Object.assign({}, this.frameState_);\n    frameState.viewState = /** @type {import(\"../View.js\").State} */\n    Object.assign({}, frameState.viewState);\n    const center = getCenter(extent);\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [center[0] - frameState.size[0] * resolution / 2, center[1] - frameState.size[1] * resolution / 2, center[0] + frameState.size[0] * resolution / 2, center[1] + frameState.size[1] * resolution / 2];\n    frameState.time = Date.now();\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   * @override\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n    this.tileQueue_.loadMoreTiles(16, 16);\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (resolution !== renderedResolution || !equals(frameState.extent, renderedExtent)) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {\n      this.processSources_();\n    }\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n    const data = {};\n    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));\n    this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (resolution !== this.requestedFrameState_.viewState.resolution || !equals(extent, this.requestedFrameState_.extent)) {\n      return;\n    }\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(extent, resolution, 1, context.canvas);\n    }\n    context.putImageData(output, 0, 0);\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({\n        source: layerOrSource\n      });\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({\n        source: layerOrSource\n      });\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\nexport default RasterSource;","map":{"version":3,"names":["Disposable","Event","EventType","ImageCanvas","ImageLayer","ImageSource","Source","TileLayer","TileQueue","TileSource","createCanvasContext2D","create","createTransform","equals","getCenter","getHeight","getWidth","getUid","createMinion","operation","data","buffers","meta","imageOps","width","height","numBuffers","length","numBytes","byteLength","images","Array","b","ImageData","Uint8ClampedArray","output","buffer","arrays","pixels","i","j","array","pixel","createWorker","config","onMessage","lib","Object","keys","map","name","toString","lines","concat","worker","Worker","Blob","Buffer","from","join","URL","createObjectURL","type","addEventListener","createFauxWorker","minion","terminated","postMessage","setTimeout","terminate","Processor","constructor","imageOps_","threads","workers","onWorkerMessage_","bind","workers_","queue_","maxQueueLength_","queue","Infinity","running_","dataLookup_","job_","process","inputs","callback","enqueue_","dispatch_","job","push","shift","input","segmentLength","Math","ceil","offset","slices","jj","slice","index","event","disposed","resolveJob_","set","disposeInternal","RasterEventType","BEFOREOPERATIONS","AFTEROPERATIONS","RasterSourceEvent","frameState","extent","resolution","viewState","pixelRatio","RasterSource","options","projection","on","once","un","processor_","operationType_","operationType","undefined","threads_","layers_","createLayers","sources","changed","ii","CHANGE","useResolutions_","resolutions","tileQueue_","processSources_","requestedFrameState_","renderedImageCanvas_","renderedRevision_","frameState_","animate","coordinateToPixelTransform","declutter","layerIndex","layerStatesArray","getLayerStatesArray","pixelToCoordinateTransform","postRenderFunctions","size","tileQueue","time","Date","now","usedTiles","rotation","viewHints","wantedTiles","mapId","renderTargets","setAttributions","attributions","iMax","sourceOrLayer","source","getSource","sourceAttributions","getAttributions","setOperation","dispose","updateFrameState_","assign","center","allSourcesReady_","ready","getState","getImage","loadMoreTiles","findNearestResolution","renderedResolution","getResolution","renderedExtent","getExtent","getRevision","requestAnimationFrame","len","imageDatas","imageData","getImageData","dispatchEvent","onWorkerComplete_","err","context","getContext","round","canvas","putImageData","getResolutions","prototype","sharedContext","layer","renderer","getRenderer","Error","prepareFrame","container","renderFrame","element","HTMLCanvasElement","firstElementChild","willReadFrequently","clearRect","drawImage","layers","getLayerState","createLayer","layerOrSource"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/source/Raster.js"],"sourcesContent":["/**\n * @module ol/source/Raster\n */\nimport Disposable from '../Disposable.js';\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageCanvas from '../ImageCanvas.js';\nimport ImageLayer from '../layer/Image.js';\nimport ImageSource from './Image.js';\nimport Source from './Source.js';\nimport TileLayer from '../layer/Tile.js';\nimport TileQueue from '../TileQueue.js';\nimport TileSource from './Tile.js';\nimport {createCanvasContext2D} from '../dom.js';\nimport {create as createTransform} from '../transform.js';\nimport {equals, getCenter, getHeight, getWidth} from '../extent.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} MinionData\n * @property {Array<ArrayBuffer>} buffers Array of buffers.\n * @property {Object} meta Operation metadata.\n * @property {boolean} imageOps The operation is an image operation.\n * @property {number} width The width of the image.\n * @property {number} height The height of the image.\n */\n\n/* istanbul ignore next */\n/**\n * Create a function for running operations.  This function is serialized for\n * use in a worker.\n * @param {function(Array, Object):*} operation The operation.\n * @return {function(MinionData):ArrayBuffer} A function that takes an object with\n * buffers, meta, imageOps, width, and height properties and returns an array\n * buffer.\n */\nfunction createMinion(operation) {\n  return function (data) {\n    // bracket notation for minification support\n    const buffers = data['buffers'];\n    const meta = data['meta'];\n    const imageOps = data['imageOps'];\n    const width = data['width'];\n    const height = data['height'];\n\n    const numBuffers = buffers.length;\n    const numBytes = buffers[0].byteLength;\n\n    if (imageOps) {\n      const images = new Array(numBuffers);\n      for (let b = 0; b < numBuffers; ++b) {\n        images[b] = new ImageData(\n          new Uint8ClampedArray(buffers[b]),\n          width,\n          height,\n        );\n      }\n      const output = operation(images, meta).data;\n      return output.buffer;\n    }\n\n    const output = new Uint8ClampedArray(numBytes);\n    const arrays = new Array(numBuffers);\n    const pixels = new Array(numBuffers);\n    for (let b = 0; b < numBuffers; ++b) {\n      arrays[b] = new Uint8ClampedArray(buffers[b]);\n      pixels[b] = [0, 0, 0, 0];\n    }\n    for (let i = 0; i < numBytes; i += 4) {\n      for (let j = 0; j < numBuffers; ++j) {\n        const array = arrays[j];\n        pixels[j][0] = array[i];\n        pixels[j][1] = array[i + 1];\n        pixels[j][2] = array[i + 2];\n        pixels[j][3] = array[i + 3];\n      }\n      const pixel = operation(pixels, meta);\n      output[i] = pixel[0];\n      output[i + 1] = pixel[1];\n      output[i + 2] = pixel[2];\n      output[i + 3] = pixel[3];\n    }\n    return output.buffer;\n  };\n}\n\n/**\n * Create a worker for running operations.\n * @param {ProcessorOptions} config Processor options.\n * @param {function(MessageEvent): void} onMessage Called with a message event.\n * @return {Worker} The worker.\n */\nfunction createWorker(config, onMessage) {\n  const lib = Object.keys(config.lib || {}).map(function (name) {\n    return 'const ' + name + ' = ' + config.lib[name].toString() + ';';\n  });\n\n  const lines = lib.concat([\n    'const __minion__ = (' + createMinion.toString() + ')(',\n    config.operation.toString(),\n    ');',\n    'self.addEventListener(\"message\", function(event) {',\n    '  const buffer = __minion__(event.data);',\n    '  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);',\n    '});',\n  ]);\n\n  const worker = new Worker(\n    typeof Blob === 'undefined'\n      ? 'data:text/javascript;base64,' +\n        Buffer.from(lines.join('\\n'), 'binary').toString('base64')\n      : URL.createObjectURL(new Blob(lines, {type: 'text/javascript'})),\n  );\n  worker.addEventListener('message', onMessage);\n  return worker;\n}\n\n/**\n * @typedef {Object} FauxMessageEvent\n * @property {Object} data Message data.\n */\n\n/**\n * Create a faux worker for running operations.\n * @param {ProcessorOptions} config Configuration.\n * @param {function(FauxMessageEvent): void} onMessage Called with a message event.\n * @return {Object} The faux worker.\n */\nfunction createFauxWorker(config, onMessage) {\n  const minion = createMinion(config.operation);\n  let terminated = false;\n  return {\n    postMessage: function (data) {\n      setTimeout(function () {\n        if (terminated) {\n          return;\n        }\n        onMessage({data: {buffer: minion(data), meta: data['meta']}});\n      }, 0);\n    },\n    terminate: function () {\n      terminated = true;\n    },\n  };\n}\n\n/**\n * @typedef {function(Error, ImageData, (Object|Array<Object>)): void} JobCallback\n */\n\n/**\n * @typedef {Object} Job\n * @property {Object} meta Job metadata.\n * @property {Array<ImageData>} inputs Array of input data.\n * @property {JobCallback} callback Called when the job is complete.\n */\n\n/**\n * @typedef {Object} ProcessorOptions\n * @property {number} threads Number of workers to spawn.\n * @property {Operation} operation The operation.\n * @property {Object<string, Function>} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} queue The number of queued jobs to allow.\n * @property {boolean} [imageOps=false] Pass all the image data to the operation instead of a single pixel.\n */\n\n/**\n * @classdesc\n * A processor runs pixel or image operations in workers.\n */\nexport class Processor extends Disposable {\n  /**\n   * @param {ProcessorOptions} config Configuration.\n   */\n  constructor(config) {\n    super();\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.imageOps_ = !!config.imageOps;\n    let threads;\n    if (config.threads === 0) {\n      threads = 0;\n    } else if (this.imageOps_) {\n      threads = 1;\n    } else {\n      threads = config.threads || 1;\n    }\n\n    /**\n     * @type {Array<Worker>}\n     */\n    const workers = new Array(threads);\n    if (threads) {\n      for (let i = 0; i < threads; ++i) {\n        workers[i] = createWorker(config, this.onWorkerMessage_.bind(this, i));\n      }\n    } else {\n      workers[0] = createFauxWorker(\n        config,\n        this.onWorkerMessage_.bind(this, 0),\n      );\n    }\n    /**\n     * @type {Array<Worker>}\n     * @private\n     */\n    this.workers_ = workers;\n\n    /**\n     * @type {Array<Job>}\n     * @private\n     */\n    this.queue_ = [];\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.maxQueueLength_ = config.queue || Infinity;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.running_ = 0;\n\n    /**\n     * @type {Object<number, any>}\n     * @private\n     */\n    this.dataLookup_ = {};\n\n    /**\n     * @type {Job|null}\n     * @private\n     */\n    this.job_ = null;\n  }\n\n  /**\n   * Run operation on input data.\n   * @param {Array<ImageData>} inputs Array of image data.\n   * @param {Object} meta A user data object.  This is passed to all operations\n   *     and must be serializable.\n   * @param {function(Error, ImageData, Object): void} callback Called when work\n   *     completes.  The first argument is any error.  The second is the ImageData\n   *     generated by operations.  The third is the user data object.\n   */\n  process(inputs, meta, callback) {\n    this.enqueue_({\n      inputs: inputs,\n      meta: meta,\n      callback: callback,\n    });\n    this.dispatch_();\n  }\n\n  /**\n   * Add a job to the queue.\n   * @param {Job} job The job.\n   */\n  enqueue_(job) {\n    this.queue_.push(job);\n    while (this.queue_.length > this.maxQueueLength_) {\n      this.queue_.shift().callback(null, null);\n    }\n  }\n\n  /**\n   * Dispatch a job.\n   */\n  dispatch_() {\n    if (this.running_ || this.queue_.length === 0) {\n      return;\n    }\n\n    const job = this.queue_.shift();\n    this.job_ = job;\n    const width = job.inputs[0].width;\n    const height = job.inputs[0].height;\n    const buffers = job.inputs.map(function (input) {\n      return input.data.buffer;\n    });\n    const threads = this.workers_.length;\n    this.running_ = threads;\n    if (threads === 1) {\n      this.workers_[0].postMessage(\n        {\n          buffers: buffers,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        buffers,\n      );\n      return;\n    }\n\n    const length = job.inputs[0].data.length;\n    const segmentLength = 4 * Math.ceil(length / 4 / threads);\n    for (let i = 0; i < threads; ++i) {\n      const offset = i * segmentLength;\n      const slices = [];\n      for (let j = 0, jj = buffers.length; j < jj; ++j) {\n        slices.push(buffers[j].slice(offset, offset + segmentLength));\n      }\n      this.workers_[i].postMessage(\n        {\n          buffers: slices,\n          meta: job.meta,\n          imageOps: this.imageOps_,\n          width: width,\n          height: height,\n        },\n        slices,\n      );\n    }\n  }\n\n  /**\n   * Handle messages from the worker.\n   * @param {number} index The worker index.\n   * @param {MessageEvent} event The message event.\n   */\n  onWorkerMessage_(index, event) {\n    if (this.disposed) {\n      return;\n    }\n    this.dataLookup_[index] = event.data;\n    --this.running_;\n    if (this.running_ === 0) {\n      this.resolveJob_();\n    }\n  }\n\n  /**\n   * Resolve a job.  If there are no more worker threads, the processor callback\n   * will be called.\n   */\n  resolveJob_() {\n    const job = this.job_;\n    const threads = this.workers_.length;\n    let data, meta;\n    if (threads === 1) {\n      data = new Uint8ClampedArray(this.dataLookup_[0]['buffer']);\n      meta = this.dataLookup_[0]['meta'];\n    } else {\n      const length = job.inputs[0].data.length;\n      data = new Uint8ClampedArray(length);\n      meta = new Array(threads);\n      const segmentLength = 4 * Math.ceil(length / 4 / threads);\n      for (let i = 0; i < threads; ++i) {\n        const buffer = this.dataLookup_[i]['buffer'];\n        const offset = i * segmentLength;\n        data.set(new Uint8ClampedArray(buffer), offset);\n        meta[i] = this.dataLookup_[i]['meta'];\n      }\n    }\n    this.job_ = null;\n    this.dataLookup_ = {};\n    job.callback(\n      null,\n      new ImageData(data, job.inputs[0].width, job.inputs[0].height),\n      meta,\n    );\n    this.dispatch_();\n  }\n\n  /**\n   * Terminate all workers associated with the processor.\n   * @override\n   */\n  disposeInternal() {\n    for (let i = 0; i < this.workers_.length; ++i) {\n      this.workers_[i].terminate();\n    }\n    this.workers_.length = 0;\n  }\n}\n\n/**\n * A function that takes an array of input data, performs some operation, and\n * returns an array of output data.\n * For `pixel` type operations, the function will be called with an array of\n * pixels, where each pixel is an array of four numbers (`[r, g, b, a]`) in the\n * range of 0 - 255. It should return a single pixel array.\n * For `'image'` type operations, functions will be called with an array of\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData)\n * and should return a single\n * [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n * The operations\n * are called with a second \"data\" argument, which can be used for storage.  The\n * data object is accessible from raster events, where it can be initialized in\n * \"beforeoperations\" and accessed again in \"afteroperations\".\n *\n * @typedef {function((Array<Array<number>>|Array<ImageData>), Object):\n *     (Array<number>|ImageData)} Operation\n */\n\n/**\n * @enum {string}\n */\nconst RasterEventType = {\n  /**\n   * Triggered before operations are run.  Listeners will receive an event object with\n   * a `data` property that can be used to make data available to operations.\n   * @event module:ol/source/Raster.RasterSourceEvent#beforeoperations\n   * @api\n   */\n  BEFOREOPERATIONS: 'beforeoperations',\n\n  /**\n   * Triggered after operations are run.  Listeners will receive an event object with\n   * a `data` property.  If more than one thread is used, `data` will be an array of\n   * objects.  If a single thread is used, `data` will be a single object.\n   * @event module:ol/source/Raster.RasterSourceEvent#afteroperations\n   * @api\n   */\n  AFTEROPERATIONS: 'afteroperations',\n};\n\n/**\n * @typedef {'pixel' | 'image'} RasterOperationType\n * Raster operation type. Supported values are `'pixel'` and `'image'`.\n */\n\n/**\n * @typedef {import(\"./Image.js\").ImageSourceEventTypes|'beforeoperations'|'afteroperations'} RasterSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Raster~RasterSource} instances are instances of this\n * type.\n */\nexport class RasterSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Object|Array<Object>} data An object made available to operations.  For \"afteroperations\" evenets\n   * this will be an array of objects if more than one thread is used.\n   */\n  constructor(type, frameState, data) {\n    super(type);\n\n    /**\n     * The raster extent.\n     * @type {import(\"../extent.js\").Extent}\n     * @api\n     */\n    this.extent = frameState.extent;\n\n    /**\n     * The pixel resolution (map units per pixel).\n     * @type {number}\n     * @api\n     */\n    this.resolution = frameState.viewState.resolution / frameState.pixelRatio;\n\n    /**\n     * An object made available to all operations.  This can be used by operations\n     * as a storage object (e.g. for calculating statistics).\n     * @type {Object}\n     * @api\n     */\n    this.data = data;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources Input\n * sources or layers.  For vector data, use an VectorImage layer.\n * @property {Operation} [operation] Raster operation.\n * The operation will be called with data from input sources\n * and the output will be assigned to the raster source.\n * @property {Object} [lib] Functions that will be made available to operations run in a worker.\n * @property {number} [threads] By default, operations will be run in a single worker thread.\n * To avoid using workers altogether, set `threads: 0`.  For pixel operations, operations can\n * be run in multiple worker threads.  Note that there is additional overhead in\n * transferring data to multiple workers, and that depending on the user's\n * system, it may not be possible to parallelize the work.\n * @property {RasterOperationType} [operationType='pixel'] Operation type.\n * Supported values are `'pixel'` and `'image'`.  By default,\n * `'pixel'` operations are assumed, and operations will be called with an\n * array of pixels from input sources.  If set to `'image'`, operations will\n * be called with an array of ImageData objects from input sources.\n * @property {Array<number>|null} [resolutions] Resolutions. If specified, raster operations will only\n * be run at the given resolutions.  By default, the resolutions of the first source with resolutions\n * specified will be used, if any. Set to `null` to use any view resolution instead.\n */\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<import(\"./Image.js\").ImageSourceEventTypes, import(\"./Image.js\").ImageSourceEvent, Return> &\n *   import(\"../Observable\").OnSignature<RasterSourceEventTypes, RasterSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |RasterSourceEventTypes, Return>} RasterSourceOnSignature\n */\n\n/**\n * @classdesc\n * A source that transforms data from any number of input sources using an\n * {@link module:ol/source/Raster~Operation} function to transform input pixel values into\n * output pixel values.\n *\n * @fires module:ol/source/Raster.RasterSourceEvent\n * @api\n */\nclass RasterSource extends ImageSource {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    super({\n      projection: null,\n    });\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {RasterSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {RasterSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @private\n     * @type {Processor}\n     */\n    this.processor_ = null;\n\n    /**\n     * @private\n     * @type {RasterOperationType}\n     */\n    this.operationType_ =\n      options.operationType !== undefined ? options.operationType : 'pixel';\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threads_ = options.threads !== undefined ? options.threads : 1;\n\n    /**\n     * @private\n     * @type {Array<import(\"../layer/Layer.js\").default>}\n     */\n    this.layers_ = createLayers(options.sources);\n\n    const changed = this.changed.bind(this);\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      this.layers_[i].addEventListener(EventType.CHANGE, changed);\n    }\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useResolutions_ = options.resolutions !== null;\n\n    /**\n     * @private\n     * @type {import(\"../TileQueue.js\").default}\n     */\n    this.tileQueue_ = new TileQueue(function () {\n      return 1;\n    }, this.processSources_.bind(this));\n\n    /**\n     * The most recently requested frame state.\n     * @type {import(\"../Map.js\").FrameState}\n     * @private\n     */\n    this.requestedFrameState_;\n\n    /**\n     * The most recently rendered image canvas.\n     * @type {import(\"../ImageCanvas.js\").default}\n     * @private\n     */\n    this.renderedImageCanvas_ = null;\n\n    /**\n     * The most recently rendered revision.\n     * @type {number}\n     * @private\n     */\n    this.renderedRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").FrameState}\n     */\n    this.frameState_ = {\n      animate: false,\n      coordinateToPixelTransform: createTransform(),\n      declutter: null,\n      extent: null,\n      index: 0,\n      layerIndex: 0,\n      layerStatesArray: getLayerStatesArray(this.layers_),\n      pixelRatio: 1,\n      pixelToCoordinateTransform: createTransform(),\n      postRenderFunctions: [],\n      size: [0, 0],\n      tileQueue: this.tileQueue_,\n      time: Date.now(),\n      usedTiles: {},\n      viewState: /** @type {import(\"../View.js\").State} */ ({\n        rotation: 0,\n      }),\n      viewHints: [],\n      wantedTiles: {},\n      mapId: getUid(this),\n      renderTargets: {},\n    };\n\n    this.setAttributions(function (frameState) {\n      /** @type {Array<string>} */\n      const attributions = [];\n      for (let i = 0, iMax = options.sources.length; i < iMax; ++i) {\n        const sourceOrLayer = options.sources[i];\n        const source =\n          sourceOrLayer instanceof Source\n            ? sourceOrLayer\n            : sourceOrLayer.getSource();\n        if (!source) {\n          continue;\n        }\n        const sourceAttributions = source.getAttributions()?.(frameState);\n        if (typeof sourceAttributions === 'string') {\n          attributions.push(sourceAttributions);\n        } else if (sourceAttributions !== undefined) {\n          attributions.push(...sourceAttributions);\n        }\n      }\n      return attributions;\n    });\n\n    if (options.operation !== undefined) {\n      this.setOperation(options.operation, options.lib);\n    }\n  }\n\n  /**\n   * Set the operation.\n   * @param {Operation} operation New operation.\n   * @param {Object} [lib] Functions that will be available to operations run\n   *     in a worker.\n   * @api\n   */\n  setOperation(operation, lib) {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n\n    this.processor_ = new Processor({\n      operation: operation,\n      imageOps: this.operationType_ === 'image',\n      queue: 1,\n      lib: lib,\n      threads: this.threads_,\n    });\n    this.changed();\n  }\n\n  /**\n   * Update the stored frame state.\n   * @param {import(\"../extent.js\").Extent} extent The view extent (in map units).\n   * @param {number} resolution The view resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection The view projection.\n   * @return {import(\"../Map.js\").FrameState} The updated frame state.\n   * @private\n   */\n  updateFrameState_(extent, resolution, projection) {\n    const frameState = /** @type {import(\"../Map.js\").FrameState} */ (\n      Object.assign({}, this.frameState_)\n    );\n\n    frameState.viewState = /** @type {import(\"../View.js\").State} */ (\n      Object.assign({}, frameState.viewState)\n    );\n\n    const center = getCenter(extent);\n\n    frameState.size[0] = Math.ceil(getWidth(extent) / resolution);\n    frameState.size[1] = Math.ceil(getHeight(extent) / resolution);\n    frameState.extent = [\n      center[0] - (frameState.size[0] * resolution) / 2,\n      center[1] - (frameState.size[1] * resolution) / 2,\n      center[0] + (frameState.size[0] * resolution) / 2,\n      center[1] + (frameState.size[1] * resolution) / 2,\n    ];\n    frameState.time = Date.now();\n\n    const viewState = frameState.viewState;\n    viewState.center = center;\n    viewState.projection = projection;\n    viewState.resolution = resolution;\n    return frameState;\n  }\n\n  /**\n   * Determine if all sources are ready.\n   * @return {boolean} All sources are ready.\n   * @private\n   */\n  allSourcesReady_() {\n    let ready = true;\n    let source;\n    for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n      source = this.layers_[i].getSource();\n      if (!source || source.getState() !== 'ready') {\n        ready = false;\n        break;\n      }\n    }\n    return ready;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../ImageCanvas.js\").default} Single image.\n   * @override\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    if (!this.allSourcesReady_()) {\n      return null;\n    }\n\n    this.tileQueue_.loadMoreTiles(16, 16);\n\n    resolution = this.findNearestResolution(resolution);\n    const frameState = this.updateFrameState_(extent, resolution, projection);\n    this.requestedFrameState_ = frameState;\n\n    // check if we can't reuse the existing ol/ImageCanvas\n    if (this.renderedImageCanvas_) {\n      const renderedResolution = this.renderedImageCanvas_.getResolution();\n      const renderedExtent = this.renderedImageCanvas_.getExtent();\n      if (\n        resolution !== renderedResolution ||\n        !equals(frameState.extent, renderedExtent)\n      ) {\n        this.renderedImageCanvas_ = null;\n      }\n    }\n\n    if (\n      !this.renderedImageCanvas_ ||\n      this.getRevision() !== this.renderedRevision_\n    ) {\n      this.processSources_();\n    }\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    }\n\n    return this.renderedImageCanvas_;\n  }\n\n  /**\n   * Start processing source data.\n   * @private\n   */\n  processSources_() {\n    const frameState = this.requestedFrameState_;\n    const len = this.layers_.length;\n    const imageDatas = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      frameState.layerIndex = i;\n      frameState.renderTargets = {};\n      const imageData = getImageData(this.layers_[i], frameState);\n      if (imageData) {\n        imageDatas[i] = imageData;\n      } else {\n        return;\n      }\n    }\n\n    const data = {};\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data),\n    );\n    this.processor_.process(\n      imageDatas,\n      data,\n      this.onWorkerComplete_.bind(this, frameState),\n    );\n  }\n\n  /**\n   * Called when pixel processing is complete.\n   * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n   * @param {Error} err Any error during processing.\n   * @param {ImageData} output The output image data.\n   * @param {Object|Array<Object>} data The user data (or an array if more than one thread).\n   * @private\n   */\n  onWorkerComplete_(frameState, err, output, data) {\n    if (err || !output) {\n      return;\n    }\n\n    // do nothing if extent or resolution changed\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    if (\n      resolution !== this.requestedFrameState_.viewState.resolution ||\n      !equals(extent, this.requestedFrameState_.extent)\n    ) {\n      return;\n    }\n\n    let context;\n    if (this.renderedImageCanvas_) {\n      context = this.renderedImageCanvas_.getImage().getContext('2d');\n    } else {\n      const width = Math.round(getWidth(extent) / resolution);\n      const height = Math.round(getHeight(extent) / resolution);\n      context = createCanvasContext2D(width, height);\n      this.renderedImageCanvas_ = new ImageCanvas(\n        extent,\n        resolution,\n        1,\n        context.canvas,\n      );\n    }\n    context.putImageData(output, 0, 0);\n\n    if (frameState.animate) {\n      requestAnimationFrame(this.changed.bind(this));\n    } else {\n      this.changed();\n    }\n    this.renderedRevision_ = this.getRevision();\n\n    this.dispatchEvent(\n      new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data),\n    );\n  }\n\n  /**\n   * @param {import(\"../proj/Projection\").default} [projection] Projection.\n   * @return {Array<number>|null} Resolutions.\n   * @override\n   */\n  getResolutions(projection) {\n    if (!this.useResolutions_) {\n      return null;\n    }\n    let resolutions = super.getResolutions();\n    if (!resolutions) {\n      for (let i = 0, ii = this.layers_.length; i < ii; ++i) {\n        const source = this.layers_[i].getSource();\n        resolutions = source.getResolutions(projection);\n        if (resolutions) {\n          break;\n        }\n      }\n    }\n    return resolutions;\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    if (this.processor_) {\n      this.processor_.dispose();\n    }\n    super.disposeInternal();\n  }\n}\n\n/**\n * Clean up and unregister the worker.\n * @function\n * @api\n */\nRasterSource.prototype.dispose;\n\n/**\n * A reusable canvas context.\n * @type {CanvasRenderingContext2D}\n * @private\n */\nlet sharedContext = null;\n\n/**\n * Get image data from a layer.\n * @param {import(\"../layer/Layer.js\").default} layer Layer to render.\n * @param {import(\"../Map.js\").FrameState} frameState The frame state.\n * @return {ImageData} The image data.\n */\nfunction getImageData(layer, frameState) {\n  const renderer = layer.getRenderer();\n  if (!renderer) {\n    throw new Error('Unsupported layer type: ' + layer);\n  }\n\n  if (!renderer.prepareFrame(frameState)) {\n    return null;\n  }\n  const width = frameState.size[0];\n  const height = frameState.size[1];\n  if (width === 0 || height === 0) {\n    return null;\n  }\n  const container = renderer.renderFrame(frameState, null);\n  let element;\n  if (container instanceof HTMLCanvasElement) {\n    element = container;\n  } else {\n    if (container) {\n      element = container.firstElementChild;\n    }\n    if (!(element instanceof HTMLCanvasElement)) {\n      throw new Error('Unsupported rendered element: ' + element);\n    }\n    if (element.width === width && element.height === height) {\n      const context = element.getContext('2d');\n      return context.getImageData(0, 0, width, height);\n    }\n  }\n\n  if (!sharedContext) {\n    sharedContext = createCanvasContext2D(width, height, undefined, {\n      willReadFrequently: true,\n    });\n  } else {\n    const canvas = sharedContext.canvas;\n    if (canvas.width !== width || canvas.height !== height) {\n      sharedContext = createCanvasContext2D(width, height, undefined, {\n        willReadFrequently: true,\n      });\n    } else {\n      sharedContext.clearRect(0, 0, width, height);\n    }\n  }\n  sharedContext.drawImage(element, 0, 0, width, height);\n  return sharedContext.getImageData(0, 0, width, height);\n}\n\n/**\n * Get a list of layer states from a list of layers.\n * @param {Array<import(\"../layer/Layer.js\").default>} layers Layers.\n * @return {Array<import(\"../layer/Layer.js\").State>} The layer states.\n */\nfunction getLayerStatesArray(layers) {\n  return layers.map(function (layer) {\n    return layer.getLayerState();\n  });\n}\n\n/**\n * Create layers for all sources.\n * @param {Array<import(\"./Source.js\").default|import(\"../layer/Layer.js\").default>} sources The sources.\n * @return {Array<import(\"../layer/Layer.js\").default>} Array of layers.\n */\nfunction createLayers(sources) {\n  const len = sources.length;\n  const layers = new Array(len);\n  for (let i = 0; i < len; ++i) {\n    layers[i] = createLayer(sources[i]);\n  }\n  return layers;\n}\n\n/**\n * Create a layer for the provided source.\n * @param {import(\"./Source.js\").default|import(\"../layer/Layer.js\").default} layerOrSource The layer or source.\n * @return {import(\"../layer/Layer.js\").default} The layer.\n */\nfunction createLayer(layerOrSource) {\n  // @type {import(\"../layer/Layer.js\").default}\n  let layer;\n  if (layerOrSource instanceof Source) {\n    if (layerOrSource instanceof TileSource) {\n      layer = new TileLayer({source: layerOrSource});\n    } else if (layerOrSource instanceof ImageSource) {\n      layer = new ImageLayer({source: layerOrSource});\n    }\n  } else {\n    layer = layerOrSource;\n  }\n  return layer;\n}\n\nexport default RasterSource;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,UAAU,MAAM,kBAAkB;AACzC,OAAOC,KAAK,MAAM,oBAAoB;AACtC,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,WAAW,MAAM,mBAAmB;AAC3C,OAAOC,UAAU,MAAM,mBAAmB;AAC1C,OAAOC,WAAW,MAAM,YAAY;AACpC,OAAOC,MAAM,MAAM,aAAa;AAChC,OAAOC,SAAS,MAAM,kBAAkB;AACxC,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,UAAU,MAAM,WAAW;AAClC,SAAQC,qBAAqB,QAAO,WAAW;AAC/C,SAAQC,MAAM,IAAIC,eAAe,QAAO,iBAAiB;AACzD,SAAQC,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,QAAO,cAAc;AACnE,SAAQC,MAAM,QAAO,YAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,SAAS,EAAE;EAC/B,OAAO,UAAUC,IAAI,EAAE;IACrB;IACA,MAAMC,OAAO,GAAGD,IAAI,CAAC,SAAS,CAAC;IAC/B,MAAME,IAAI,GAAGF,IAAI,CAAC,MAAM,CAAC;IACzB,MAAMG,QAAQ,GAAGH,IAAI,CAAC,UAAU,CAAC;IACjC,MAAMI,KAAK,GAAGJ,IAAI,CAAC,OAAO,CAAC;IAC3B,MAAMK,MAAM,GAAGL,IAAI,CAAC,QAAQ,CAAC;IAE7B,MAAMM,UAAU,GAAGL,OAAO,CAACM,MAAM;IACjC,MAAMC,QAAQ,GAAGP,OAAO,CAAC,CAAC,CAAC,CAACQ,UAAU;IAEtC,IAAIN,QAAQ,EAAE;MACZ,MAAMO,MAAM,GAAG,IAAIC,KAAK,CAACL,UAAU,CAAC;MACpC,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,UAAU,EAAE,EAAEM,CAAC,EAAE;QACnCF,MAAM,CAACE,CAAC,CAAC,GAAG,IAAIC,SAAS,CACvB,IAAIC,iBAAiB,CAACb,OAAO,CAACW,CAAC,CAAC,CAAC,EACjCR,KAAK,EACLC,MACF,CAAC;MACH;MACA,MAAMU,MAAM,GAAGhB,SAAS,CAACW,MAAM,EAAER,IAAI,CAAC,CAACF,IAAI;MAC3C,OAAOe,MAAM,CAACC,MAAM;IACtB;IAEA,MAAMD,MAAM,GAAG,IAAID,iBAAiB,CAACN,QAAQ,CAAC;IAC9C,MAAMS,MAAM,GAAG,IAAIN,KAAK,CAACL,UAAU,CAAC;IACpC,MAAMY,MAAM,GAAG,IAAIP,KAAK,CAACL,UAAU,CAAC;IACpC,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,UAAU,EAAE,EAAEM,CAAC,EAAE;MACnCK,MAAM,CAACL,CAAC,CAAC,GAAG,IAAIE,iBAAiB,CAACb,OAAO,CAACW,CAAC,CAAC,CAAC;MAC7CM,MAAM,CAACN,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC1B;IACA,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,QAAQ,EAAEW,CAAC,IAAI,CAAC,EAAE;MACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,UAAU,EAAE,EAAEc,CAAC,EAAE;QACnC,MAAMC,KAAK,GAAGJ,MAAM,CAACG,CAAC,CAAC;QACvBF,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,CAAC;QACvBD,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,GAAG,CAAC,CAAC;QAC3BD,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,GAAG,CAAC,CAAC;QAC3BD,MAAM,CAACE,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGC,KAAK,CAACF,CAAC,GAAG,CAAC,CAAC;MAC7B;MACA,MAAMG,KAAK,GAAGvB,SAAS,CAACmB,MAAM,EAAEhB,IAAI,CAAC;MACrCa,MAAM,CAACI,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;MACpBP,MAAM,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;MACxBP,MAAM,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;MACxBP,MAAM,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGG,KAAK,CAAC,CAAC,CAAC;IAC1B;IACA,OAAOP,MAAM,CAACC,MAAM;EACtB,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,YAAYA,CAACC,MAAM,EAAEC,SAAS,EAAE;EACvC,MAAMC,GAAG,GAAGC,MAAM,CAACC,IAAI,CAACJ,MAAM,CAACE,GAAG,IAAI,CAAC,CAAC,CAAC,CAACG,GAAG,CAAC,UAAUC,IAAI,EAAE;IAC5D,OAAO,QAAQ,GAAGA,IAAI,GAAG,KAAK,GAAGN,MAAM,CAACE,GAAG,CAACI,IAAI,CAAC,CAACC,QAAQ,CAAC,CAAC,GAAG,GAAG;EACpE,CAAC,CAAC;EAEF,MAAMC,KAAK,GAAGN,GAAG,CAACO,MAAM,CAAC,CACvB,sBAAsB,GAAGnC,YAAY,CAACiC,QAAQ,CAAC,CAAC,GAAG,IAAI,EACvDP,MAAM,CAACzB,SAAS,CAACgC,QAAQ,CAAC,CAAC,EAC3B,IAAI,EACJ,oDAAoD,EACpD,0CAA0C,EAC1C,wEAAwE,EACxE,KAAK,CACN,CAAC;EAEF,MAAMG,MAAM,GAAG,IAAIC,MAAM,CACvB,OAAOC,IAAI,KAAK,WAAW,GACvB,8BAA8B,GAC9BC,MAAM,CAACC,IAAI,CAACN,KAAK,CAACO,IAAI,CAAC,IAAI,CAAC,EAAE,QAAQ,CAAC,CAACR,QAAQ,CAAC,QAAQ,CAAC,GAC1DS,GAAG,CAACC,eAAe,CAAC,IAAIL,IAAI,CAACJ,KAAK,EAAE;IAACU,IAAI,EAAE;EAAiB,CAAC,CAAC,CACpE,CAAC;EACDR,MAAM,CAACS,gBAAgB,CAAC,SAAS,EAAElB,SAAS,CAAC;EAC7C,OAAOS,MAAM;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,gBAAgBA,CAACpB,MAAM,EAAEC,SAAS,EAAE;EAC3C,MAAMoB,MAAM,GAAG/C,YAAY,CAAC0B,MAAM,CAACzB,SAAS,CAAC;EAC7C,IAAI+C,UAAU,GAAG,KAAK;EACtB,OAAO;IACLC,WAAW,EAAE,SAAAA,CAAU/C,IAAI,EAAE;MAC3BgD,UAAU,CAAC,YAAY;QACrB,IAAIF,UAAU,EAAE;UACd;QACF;QACArB,SAAS,CAAC;UAACzB,IAAI,EAAE;YAACgB,MAAM,EAAE6B,MAAM,CAAC7C,IAAI,CAAC;YAAEE,IAAI,EAAEF,IAAI,CAAC,MAAM;UAAC;QAAC,CAAC,CAAC;MAC/D,CAAC,EAAE,CAAC,CAAC;IACP,CAAC;IACDiD,SAAS,EAAE,SAAAA,CAAA,EAAY;MACrBH,UAAU,GAAG,IAAI;IACnB;EACF,CAAC;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMI,SAAS,SAAStE,UAAU,CAAC;EACxC;AACF;AACA;EACEuE,WAAWA,CAAC3B,MAAM,EAAE;IAClB,KAAK,CAAC,CAAC;;IAEP;AACJ;AACA;AACA;IACI,IAAI,CAAC4B,SAAS,GAAG,CAAC,CAAC5B,MAAM,CAACrB,QAAQ;IAClC,IAAIkD,OAAO;IACX,IAAI7B,MAAM,CAAC6B,OAAO,KAAK,CAAC,EAAE;MACxBA,OAAO,GAAG,CAAC;IACb,CAAC,MAAM,IAAI,IAAI,CAACD,SAAS,EAAE;MACzBC,OAAO,GAAG,CAAC;IACb,CAAC,MAAM;MACLA,OAAO,GAAG7B,MAAM,CAAC6B,OAAO,IAAI,CAAC;IAC/B;;IAEA;AACJ;AACA;IACI,MAAMC,OAAO,GAAG,IAAI3C,KAAK,CAAC0C,OAAO,CAAC;IAClC,IAAIA,OAAO,EAAE;MACX,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,OAAO,EAAE,EAAElC,CAAC,EAAE;QAChCmC,OAAO,CAACnC,CAAC,CAAC,GAAGI,YAAY,CAACC,MAAM,EAAE,IAAI,CAAC+B,gBAAgB,CAACC,IAAI,CAAC,IAAI,EAAErC,CAAC,CAAC,CAAC;MACxE;IACF,CAAC,MAAM;MACLmC,OAAO,CAAC,CAAC,CAAC,GAAGV,gBAAgB,CAC3BpB,MAAM,EACN,IAAI,CAAC+B,gBAAgB,CAACC,IAAI,CAAC,IAAI,EAAE,CAAC,CACpC,CAAC;IACH;IACA;AACJ;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAGH,OAAO;;IAEvB;AACJ;AACA;AACA;IACI,IAAI,CAACI,MAAM,GAAG,EAAE;;IAEhB;AACJ;AACA;AACA;IACI,IAAI,CAACC,eAAe,GAAGnC,MAAM,CAACoC,KAAK,IAAIC,QAAQ;IAC/C;AACJ;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAG,CAAC;;IAEjB;AACJ;AACA;AACA;IACI,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;;IAErB;AACJ;AACA;AACA;IACI,IAAI,CAACC,IAAI,GAAG,IAAI;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,OAAOA,CAACC,MAAM,EAAEhE,IAAI,EAAEiE,QAAQ,EAAE;IAC9B,IAAI,CAACC,QAAQ,CAAC;MACZF,MAAM,EAAEA,MAAM;MACdhE,IAAI,EAAEA,IAAI;MACViE,QAAQ,EAAEA;IACZ,CAAC,CAAC;IACF,IAAI,CAACE,SAAS,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;EACED,QAAQA,CAACE,GAAG,EAAE;IACZ,IAAI,CAACZ,MAAM,CAACa,IAAI,CAACD,GAAG,CAAC;IACrB,OAAO,IAAI,CAACZ,MAAM,CAACnD,MAAM,GAAG,IAAI,CAACoD,eAAe,EAAE;MAChD,IAAI,CAACD,MAAM,CAACc,KAAK,CAAC,CAAC,CAACL,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;IAC1C;EACF;;EAEA;AACF;AACA;EACEE,SAASA,CAAA,EAAG;IACV,IAAI,IAAI,CAACP,QAAQ,IAAI,IAAI,CAACJ,MAAM,CAACnD,MAAM,KAAK,CAAC,EAAE;MAC7C;IACF;IAEA,MAAM+D,GAAG,GAAG,IAAI,CAACZ,MAAM,CAACc,KAAK,CAAC,CAAC;IAC/B,IAAI,CAACR,IAAI,GAAGM,GAAG;IACf,MAAMlE,KAAK,GAAGkE,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC9D,KAAK;IACjC,MAAMC,MAAM,GAAGiE,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC7D,MAAM;IACnC,MAAMJ,OAAO,GAAGqE,GAAG,CAACJ,MAAM,CAACrC,GAAG,CAAC,UAAU4C,KAAK,EAAE;MAC9C,OAAOA,KAAK,CAACzE,IAAI,CAACgB,MAAM;IAC1B,CAAC,CAAC;IACF,MAAMqC,OAAO,GAAG,IAAI,CAACI,QAAQ,CAAClD,MAAM;IACpC,IAAI,CAACuD,QAAQ,GAAGT,OAAO;IACvB,IAAIA,OAAO,KAAK,CAAC,EAAE;MACjB,IAAI,CAACI,QAAQ,CAAC,CAAC,CAAC,CAACV,WAAW,CAC1B;QACE9C,OAAO,EAAEA,OAAO;QAChBC,IAAI,EAAEoE,GAAG,CAACpE,IAAI;QACdC,QAAQ,EAAE,IAAI,CAACiD,SAAS;QACxBhD,KAAK,EAAEA,KAAK;QACZC,MAAM,EAAEA;MACV,CAAC,EACDJ,OACF,CAAC;MACD;IACF;IAEA,MAAMM,MAAM,GAAG+D,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAClE,IAAI,CAACO,MAAM;IACxC,MAAMmE,aAAa,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACrE,MAAM,GAAG,CAAC,GAAG8C,OAAO,CAAC;IACzD,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,OAAO,EAAE,EAAElC,CAAC,EAAE;MAChC,MAAM0D,MAAM,GAAG1D,CAAC,GAAGuD,aAAa;MAChC,MAAMI,MAAM,GAAG,EAAE;MACjB,KAAK,IAAI1D,CAAC,GAAG,CAAC,EAAE2D,EAAE,GAAG9E,OAAO,CAACM,MAAM,EAAEa,CAAC,GAAG2D,EAAE,EAAE,EAAE3D,CAAC,EAAE;QAChD0D,MAAM,CAACP,IAAI,CAACtE,OAAO,CAACmB,CAAC,CAAC,CAAC4D,KAAK,CAACH,MAAM,EAAEA,MAAM,GAAGH,aAAa,CAAC,CAAC;MAC/D;MACA,IAAI,CAACjB,QAAQ,CAACtC,CAAC,CAAC,CAAC4B,WAAW,CAC1B;QACE9C,OAAO,EAAE6E,MAAM;QACf5E,IAAI,EAAEoE,GAAG,CAACpE,IAAI;QACdC,QAAQ,EAAE,IAAI,CAACiD,SAAS;QACxBhD,KAAK,EAAEA,KAAK;QACZC,MAAM,EAAEA;MACV,CAAC,EACDyE,MACF,CAAC;IACH;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEvB,gBAAgBA,CAAC0B,KAAK,EAAEC,KAAK,EAAE;IAC7B,IAAI,IAAI,CAACC,QAAQ,EAAE;MACjB;IACF;IACA,IAAI,CAACpB,WAAW,CAACkB,KAAK,CAAC,GAAGC,KAAK,CAAClF,IAAI;IACpC,EAAE,IAAI,CAAC8D,QAAQ;IACf,IAAI,IAAI,CAACA,QAAQ,KAAK,CAAC,EAAE;MACvB,IAAI,CAACsB,WAAW,CAAC,CAAC;IACpB;EACF;;EAEA;AACF;AACA;AACA;EACEA,WAAWA,CAAA,EAAG;IACZ,MAAMd,GAAG,GAAG,IAAI,CAACN,IAAI;IACrB,MAAMX,OAAO,GAAG,IAAI,CAACI,QAAQ,CAAClD,MAAM;IACpC,IAAIP,IAAI,EAAEE,IAAI;IACd,IAAImD,OAAO,KAAK,CAAC,EAAE;MACjBrD,IAAI,GAAG,IAAIc,iBAAiB,CAAC,IAAI,CAACiD,WAAW,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC;MAC3D7D,IAAI,GAAG,IAAI,CAAC6D,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IACpC,CAAC,MAAM;MACL,MAAMxD,MAAM,GAAG+D,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAClE,IAAI,CAACO,MAAM;MACxCP,IAAI,GAAG,IAAIc,iBAAiB,CAACP,MAAM,CAAC;MACpCL,IAAI,GAAG,IAAIS,KAAK,CAAC0C,OAAO,CAAC;MACzB,MAAMqB,aAAa,GAAG,CAAC,GAAGC,IAAI,CAACC,IAAI,CAACrE,MAAM,GAAG,CAAC,GAAG8C,OAAO,CAAC;MACzD,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,OAAO,EAAE,EAAElC,CAAC,EAAE;QAChC,MAAMH,MAAM,GAAG,IAAI,CAAC+C,WAAW,CAAC5C,CAAC,CAAC,CAAC,QAAQ,CAAC;QAC5C,MAAM0D,MAAM,GAAG1D,CAAC,GAAGuD,aAAa;QAChC1E,IAAI,CAACqF,GAAG,CAAC,IAAIvE,iBAAiB,CAACE,MAAM,CAAC,EAAE6D,MAAM,CAAC;QAC/C3E,IAAI,CAACiB,CAAC,CAAC,GAAG,IAAI,CAAC4C,WAAW,CAAC5C,CAAC,CAAC,CAAC,MAAM,CAAC;MACvC;IACF;IACA,IAAI,CAAC6C,IAAI,GAAG,IAAI;IAChB,IAAI,CAACD,WAAW,GAAG,CAAC,CAAC;IACrBO,GAAG,CAACH,QAAQ,CACV,IAAI,EACJ,IAAItD,SAAS,CAACb,IAAI,EAAEsE,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC9D,KAAK,EAAEkE,GAAG,CAACJ,MAAM,CAAC,CAAC,CAAC,CAAC7D,MAAM,CAAC,EAC9DH,IACF,CAAC;IACD,IAAI,CAACmE,SAAS,CAAC,CAAC;EAClB;;EAEA;AACF;AACA;AACA;EACEiB,eAAeA,CAAA,EAAG;IAChB,KAAK,IAAInE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACsC,QAAQ,CAAClD,MAAM,EAAE,EAAEY,CAAC,EAAE;MAC7C,IAAI,CAACsC,QAAQ,CAACtC,CAAC,CAAC,CAAC8B,SAAS,CAAC,CAAC;IAC9B;IACA,IAAI,CAACQ,QAAQ,CAAClD,MAAM,GAAG,CAAC;EAC1B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMgF,eAAe,GAAG;EACtB;AACF;AACA;AACA;AACA;AACA;EACEC,gBAAgB,EAAE,kBAAkB;EAEpC;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,eAAe,EAAE;AACnB,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,SAAS7G,KAAK,CAAC;EAC3C;AACF;AACA;AACA;AACA;AACA;EACEsE,WAAWA,CAACT,IAAI,EAAEiD,UAAU,EAAE3F,IAAI,EAAE;IAClC,KAAK,CAAC0C,IAAI,CAAC;;IAEX;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACkD,MAAM,GAAGD,UAAU,CAACC,MAAM;;IAE/B;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,UAAU,GAAGF,UAAU,CAACG,SAAS,CAACD,UAAU,GAAGF,UAAU,CAACI,UAAU;;IAEzE;AACJ;AACA;AACA;AACA;AACA;IACI,IAAI,CAAC/F,IAAI,GAAGA,IAAI;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgG,YAAY,SAAS/G,WAAW,CAAC;EACrC;AACF;AACA;EACEkE,WAAWA,CAAC8C,OAAO,EAAE;IACnB,KAAK,CAAC;MACJC,UAAU,EAAE;IACd,CAAC,CAAC;;IAEF;AACJ;AACA;IACI,IAAI,CAACC,EAAE;;IAEP;AACJ;AACA;IACI,IAAI,CAACC,IAAI;;IAET;AACJ;AACA;IACI,IAAI,CAACC,EAAE;;IAEP;AACJ;AACA;AACA;IACI,IAAI,CAACC,UAAU,GAAG,IAAI;;IAEtB;AACJ;AACA;AACA;IACI,IAAI,CAACC,cAAc,GACjBN,OAAO,CAACO,aAAa,KAAKC,SAAS,GAAGR,OAAO,CAACO,aAAa,GAAG,OAAO;;IAEvE;AACJ;AACA;AACA;IACI,IAAI,CAACE,QAAQ,GAAGT,OAAO,CAAC5C,OAAO,KAAKoD,SAAS,GAAGR,OAAO,CAAC5C,OAAO,GAAG,CAAC;;IAEnE;AACJ;AACA;AACA;IACI,IAAI,CAACsD,OAAO,GAAGC,YAAY,CAACX,OAAO,CAACY,OAAO,CAAC;IAE5C,MAAMC,OAAO,GAAG,IAAI,CAACA,OAAO,CAACtD,IAAI,CAAC,IAAI,CAAC;IACvC,KAAK,IAAIrC,CAAC,GAAG,CAAC,EAAE4F,EAAE,GAAG,IAAI,CAACJ,OAAO,CAACpG,MAAM,EAAEY,CAAC,GAAG4F,EAAE,EAAE,EAAE5F,CAAC,EAAE;MACrD,IAAI,CAACwF,OAAO,CAACxF,CAAC,CAAC,CAACwB,gBAAgB,CAAC7D,SAAS,CAACkI,MAAM,EAAEF,OAAO,CAAC;IAC7D;;IAEA;AACJ;AACA;AACA;IACI,IAAI,CAACG,eAAe,GAAGhB,OAAO,CAACiB,WAAW,KAAK,IAAI;;IAEnD;AACJ;AACA;AACA;IACI,IAAI,CAACC,UAAU,GAAG,IAAI/H,SAAS,CAAC,YAAY;MAC1C,OAAO,CAAC;IACV,CAAC,EAAE,IAAI,CAACgI,eAAe,CAAC5D,IAAI,CAAC,IAAI,CAAC,CAAC;;IAEnC;AACJ;AACA;AACA;AACA;IACI,IAAI,CAAC6D,oBAAoB;;IAEzB;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,oBAAoB,GAAG,IAAI;;IAEhC;AACJ;AACA;AACA;AACA;IACI,IAAI,CAACC,iBAAiB;;IAEtB;AACJ;AACA;AACA;IACI,IAAI,CAACC,WAAW,GAAG;MACjBC,OAAO,EAAE,KAAK;MACdC,0BAA0B,EAAElI,eAAe,CAAC,CAAC;MAC7CmI,SAAS,EAAE,IAAI;MACf/B,MAAM,EAAE,IAAI;MACZX,KAAK,EAAE,CAAC;MACR2C,UAAU,EAAE,CAAC;MACbC,gBAAgB,EAAEC,mBAAmB,CAAC,IAAI,CAACnB,OAAO,CAAC;MACnDZ,UAAU,EAAE,CAAC;MACbgC,0BAA0B,EAAEvI,eAAe,CAAC,CAAC;MAC7CwI,mBAAmB,EAAE,EAAE;MACvBC,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;MACZC,SAAS,EAAE,IAAI,CAACf,UAAU;MAC1BgB,IAAI,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MAChBC,SAAS,EAAE,CAAC,CAAC;MACbxC,SAAS,GAAE,yCAA2C;QACpDyC,QAAQ,EAAE;MACZ,CAAC,CAAC;MACFC,SAAS,EAAE,EAAE;MACbC,WAAW,EAAE,CAAC,CAAC;MACfC,KAAK,EAAE7I,MAAM,CAAC,IAAI,CAAC;MACnB8I,aAAa,EAAE,CAAC;IAClB,CAAC;IAED,IAAI,CAACC,eAAe,CAAC,UAAUjD,UAAU,EAAE;MACzC;MACA,MAAMkD,YAAY,GAAG,EAAE;MACvB,KAAK,IAAI1H,CAAC,GAAG,CAAC,EAAE2H,IAAI,GAAG7C,OAAO,CAACY,OAAO,CAACtG,MAAM,EAAEY,CAAC,GAAG2H,IAAI,EAAE,EAAE3H,CAAC,EAAE;QAC5D,MAAM4H,aAAa,GAAG9C,OAAO,CAACY,OAAO,CAAC1F,CAAC,CAAC;QACxC,MAAM6H,MAAM,GACVD,aAAa,YAAY7J,MAAM,GAC3B6J,aAAa,GACbA,aAAa,CAACE,SAAS,CAAC,CAAC;QAC/B,IAAI,CAACD,MAAM,EAAE;UACX;QACF;QACA,MAAME,kBAAkB,GAAGF,MAAM,CAACG,eAAe,CAAC,CAAC,GAAGxD,UAAU,CAAC;QACjE,IAAI,OAAOuD,kBAAkB,KAAK,QAAQ,EAAE;UAC1CL,YAAY,CAACtE,IAAI,CAAC2E,kBAAkB,CAAC;QACvC,CAAC,MAAM,IAAIA,kBAAkB,KAAKzC,SAAS,EAAE;UAC3CoC,YAAY,CAACtE,IAAI,CAAC,GAAG2E,kBAAkB,CAAC;QAC1C;MACF;MACA,OAAOL,YAAY;IACrB,CAAC,CAAC;IAEF,IAAI5C,OAAO,CAAClG,SAAS,KAAK0G,SAAS,EAAE;MACnC,IAAI,CAAC2C,YAAY,CAACnD,OAAO,CAAClG,SAAS,EAAEkG,OAAO,CAACvE,GAAG,CAAC;IACnD;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE0H,YAAYA,CAACrJ,SAAS,EAAE2B,GAAG,EAAE;IAC3B,IAAI,IAAI,CAAC4E,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAAC+C,OAAO,CAAC,CAAC;IAC3B;IAEA,IAAI,CAAC/C,UAAU,GAAG,IAAIpD,SAAS,CAAC;MAC9BnD,SAAS,EAAEA,SAAS;MACpBI,QAAQ,EAAE,IAAI,CAACoG,cAAc,KAAK,OAAO;MACzC3C,KAAK,EAAE,CAAC;MACRlC,GAAG,EAAEA,GAAG;MACR2B,OAAO,EAAE,IAAI,CAACqD;IAChB,CAAC,CAAC;IACF,IAAI,CAACI,OAAO,CAAC,CAAC;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEwC,iBAAiBA,CAAC1D,MAAM,EAAEC,UAAU,EAAEK,UAAU,EAAE;IAChD,MAAMP,UAAU,GAAG;IACjBhE,MAAM,CAAC4H,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC/B,WAAW,CACnC;IAED7B,UAAU,CAACG,SAAS,GAAG;IACrBnE,MAAM,CAAC4H,MAAM,CAAC,CAAC,CAAC,EAAE5D,UAAU,CAACG,SAAS,CACvC;IAED,MAAM0D,MAAM,GAAG9J,SAAS,CAACkG,MAAM,CAAC;IAEhCD,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGtD,IAAI,CAACC,IAAI,CAAChF,QAAQ,CAACgG,MAAM,CAAC,GAAGC,UAAU,CAAC;IAC7DF,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGtD,IAAI,CAACC,IAAI,CAACjF,SAAS,CAACiG,MAAM,CAAC,GAAGC,UAAU,CAAC;IAC9DF,UAAU,CAACC,MAAM,GAAG,CAClB4D,MAAM,CAAC,CAAC,CAAC,GAAI7D,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGpC,UAAU,GAAI,CAAC,EACjD2D,MAAM,CAAC,CAAC,CAAC,GAAI7D,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGpC,UAAU,GAAI,CAAC,EACjD2D,MAAM,CAAC,CAAC,CAAC,GAAI7D,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGpC,UAAU,GAAI,CAAC,EACjD2D,MAAM,CAAC,CAAC,CAAC,GAAI7D,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC,GAAGpC,UAAU,GAAI,CAAC,CAClD;IACDF,UAAU,CAACwC,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAE5B,MAAMvC,SAAS,GAAGH,UAAU,CAACG,SAAS;IACtCA,SAAS,CAAC0D,MAAM,GAAGA,MAAM;IACzB1D,SAAS,CAACI,UAAU,GAAGA,UAAU;IACjCJ,SAAS,CAACD,UAAU,GAAGA,UAAU;IACjC,OAAOF,UAAU;EACnB;;EAEA;AACF;AACA;AACA;AACA;EACE8D,gBAAgBA,CAAA,EAAG;IACjB,IAAIC,KAAK,GAAG,IAAI;IAChB,IAAIV,MAAM;IACV,KAAK,IAAI7H,CAAC,GAAG,CAAC,EAAE4F,EAAE,GAAG,IAAI,CAACJ,OAAO,CAACpG,MAAM,EAAEY,CAAC,GAAG4F,EAAE,EAAE,EAAE5F,CAAC,EAAE;MACrD6H,MAAM,GAAG,IAAI,CAACrC,OAAO,CAACxF,CAAC,CAAC,CAAC8H,SAAS,CAAC,CAAC;MACpC,IAAI,CAACD,MAAM,IAAIA,MAAM,CAACW,QAAQ,CAAC,CAAC,KAAK,OAAO,EAAE;QAC5CD,KAAK,GAAG,KAAK;QACb;MACF;IACF;IACA,OAAOA,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,QAAQA,CAAChE,MAAM,EAAEC,UAAU,EAAEE,UAAU,EAAEG,UAAU,EAAE;IACnD,IAAI,CAAC,IAAI,CAACuD,gBAAgB,CAAC,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb;IAEA,IAAI,CAACtC,UAAU,CAAC0C,aAAa,CAAC,EAAE,EAAE,EAAE,CAAC;IAErChE,UAAU,GAAG,IAAI,CAACiE,qBAAqB,CAACjE,UAAU,CAAC;IACnD,MAAMF,UAAU,GAAG,IAAI,CAAC2D,iBAAiB,CAAC1D,MAAM,EAAEC,UAAU,EAAEK,UAAU,CAAC;IACzE,IAAI,CAACmB,oBAAoB,GAAG1B,UAAU;;IAEtC;IACA,IAAI,IAAI,CAAC2B,oBAAoB,EAAE;MAC7B,MAAMyC,kBAAkB,GAAG,IAAI,CAACzC,oBAAoB,CAAC0C,aAAa,CAAC,CAAC;MACpE,MAAMC,cAAc,GAAG,IAAI,CAAC3C,oBAAoB,CAAC4C,SAAS,CAAC,CAAC;MAC5D,IACErE,UAAU,KAAKkE,kBAAkB,IACjC,CAACtK,MAAM,CAACkG,UAAU,CAACC,MAAM,EAAEqE,cAAc,CAAC,EAC1C;QACA,IAAI,CAAC3C,oBAAoB,GAAG,IAAI;MAClC;IACF;IAEA,IACE,CAAC,IAAI,CAACA,oBAAoB,IAC1B,IAAI,CAAC6C,WAAW,CAAC,CAAC,KAAK,IAAI,CAAC5C,iBAAiB,EAC7C;MACA,IAAI,CAACH,eAAe,CAAC,CAAC;IACxB;IAEA,IAAIzB,UAAU,CAAC8B,OAAO,EAAE;MACtB2C,qBAAqB,CAAC,IAAI,CAACtD,OAAO,CAACtD,IAAI,CAAC,IAAI,CAAC,CAAC;IAChD;IAEA,OAAO,IAAI,CAAC8D,oBAAoB;EAClC;;EAEA;AACF;AACA;AACA;EACEF,eAAeA,CAAA,EAAG;IAChB,MAAMzB,UAAU,GAAG,IAAI,CAAC0B,oBAAoB;IAC5C,MAAMgD,GAAG,GAAG,IAAI,CAAC1D,OAAO,CAACpG,MAAM;IAC/B,MAAM+J,UAAU,GAAG,IAAI3J,KAAK,CAAC0J,GAAG,CAAC;IACjC,KAAK,IAAIlJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkJ,GAAG,EAAE,EAAElJ,CAAC,EAAE;MAC5BwE,UAAU,CAACiC,UAAU,GAAGzG,CAAC;MACzBwE,UAAU,CAACgD,aAAa,GAAG,CAAC,CAAC;MAC7B,MAAM4B,SAAS,GAAGC,YAAY,CAAC,IAAI,CAAC7D,OAAO,CAACxF,CAAC,CAAC,EAAEwE,UAAU,CAAC;MAC3D,IAAI4E,SAAS,EAAE;QACbD,UAAU,CAACnJ,CAAC,CAAC,GAAGoJ,SAAS;MAC3B,CAAC,MAAM;QACL;MACF;IACF;IAEA,MAAMvK,IAAI,GAAG,CAAC,CAAC;IACf,IAAI,CAACyK,aAAa,CAChB,IAAI/E,iBAAiB,CAACH,eAAe,CAACC,gBAAgB,EAAEG,UAAU,EAAE3F,IAAI,CAC1E,CAAC;IACD,IAAI,CAACsG,UAAU,CAACrC,OAAO,CACrBqG,UAAU,EACVtK,IAAI,EACJ,IAAI,CAAC0K,iBAAiB,CAAClH,IAAI,CAAC,IAAI,EAAEmC,UAAU,CAC9C,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE+E,iBAAiBA,CAAC/E,UAAU,EAAEgF,GAAG,EAAE5J,MAAM,EAAEf,IAAI,EAAE;IAC/C,IAAI2K,GAAG,IAAI,CAAC5J,MAAM,EAAE;MAClB;IACF;;IAEA;IACA,MAAM6E,MAAM,GAAGD,UAAU,CAACC,MAAM;IAChC,MAAMC,UAAU,GAAGF,UAAU,CAACG,SAAS,CAACD,UAAU;IAClD,IACEA,UAAU,KAAK,IAAI,CAACwB,oBAAoB,CAACvB,SAAS,CAACD,UAAU,IAC7D,CAACpG,MAAM,CAACmG,MAAM,EAAE,IAAI,CAACyB,oBAAoB,CAACzB,MAAM,CAAC,EACjD;MACA;IACF;IAEA,IAAIgF,OAAO;IACX,IAAI,IAAI,CAACtD,oBAAoB,EAAE;MAC7BsD,OAAO,GAAG,IAAI,CAACtD,oBAAoB,CAACsC,QAAQ,CAAC,CAAC,CAACiB,UAAU,CAAC,IAAI,CAAC;IACjE,CAAC,MAAM;MACL,MAAMzK,KAAK,GAAGuE,IAAI,CAACmG,KAAK,CAAClL,QAAQ,CAACgG,MAAM,CAAC,GAAGC,UAAU,CAAC;MACvD,MAAMxF,MAAM,GAAGsE,IAAI,CAACmG,KAAK,CAACnL,SAAS,CAACiG,MAAM,CAAC,GAAGC,UAAU,CAAC;MACzD+E,OAAO,GAAGtL,qBAAqB,CAACc,KAAK,EAAEC,MAAM,CAAC;MAC9C,IAAI,CAACiH,oBAAoB,GAAG,IAAIvI,WAAW,CACzC6G,MAAM,EACNC,UAAU,EACV,CAAC,EACD+E,OAAO,CAACG,MACV,CAAC;IACH;IACAH,OAAO,CAACI,YAAY,CAACjK,MAAM,EAAE,CAAC,EAAE,CAAC,CAAC;IAElC,IAAI4E,UAAU,CAAC8B,OAAO,EAAE;MACtB2C,qBAAqB,CAAC,IAAI,CAACtD,OAAO,CAACtD,IAAI,CAAC,IAAI,CAAC,CAAC;IAChD,CAAC,MAAM;MACL,IAAI,CAACsD,OAAO,CAAC,CAAC;IAChB;IACA,IAAI,CAACS,iBAAiB,GAAG,IAAI,CAAC4C,WAAW,CAAC,CAAC;IAE3C,IAAI,CAACM,aAAa,CAChB,IAAI/E,iBAAiB,CAACH,eAAe,CAACE,eAAe,EAAEE,UAAU,EAAE3F,IAAI,CACzE,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEiL,cAAcA,CAAC/E,UAAU,EAAE;IACzB,IAAI,CAAC,IAAI,CAACe,eAAe,EAAE;MACzB,OAAO,IAAI;IACb;IACA,IAAIC,WAAW,GAAG,KAAK,CAAC+D,cAAc,CAAC,CAAC;IACxC,IAAI,CAAC/D,WAAW,EAAE;MAChB,KAAK,IAAI/F,CAAC,GAAG,CAAC,EAAE4F,EAAE,GAAG,IAAI,CAACJ,OAAO,CAACpG,MAAM,EAAEY,CAAC,GAAG4F,EAAE,EAAE,EAAE5F,CAAC,EAAE;QACrD,MAAM6H,MAAM,GAAG,IAAI,CAACrC,OAAO,CAACxF,CAAC,CAAC,CAAC8H,SAAS,CAAC,CAAC;QAC1C/B,WAAW,GAAG8B,MAAM,CAACiC,cAAc,CAAC/E,UAAU,CAAC;QAC/C,IAAIgB,WAAW,EAAE;UACf;QACF;MACF;IACF;IACA,OAAOA,WAAW;EACpB;;EAEA;AACF;AACA;EACE5B,eAAeA,CAAA,EAAG;IAChB,IAAI,IAAI,CAACgB,UAAU,EAAE;MACnB,IAAI,CAACA,UAAU,CAAC+C,OAAO,CAAC,CAAC;IAC3B;IACA,KAAK,CAAC/D,eAAe,CAAC,CAAC;EACzB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACAU,YAAY,CAACkF,SAAS,CAAC7B,OAAO;;AAE9B;AACA;AACA;AACA;AACA;AACA,IAAI8B,aAAa,GAAG,IAAI;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA,SAASX,YAAYA,CAACY,KAAK,EAAEzF,UAAU,EAAE;EACvC,MAAM0F,QAAQ,GAAGD,KAAK,CAACE,WAAW,CAAC,CAAC;EACpC,IAAI,CAACD,QAAQ,EAAE;IACb,MAAM,IAAIE,KAAK,CAAC,0BAA0B,GAAGH,KAAK,CAAC;EACrD;EAEA,IAAI,CAACC,QAAQ,CAACG,YAAY,CAAC7F,UAAU,CAAC,EAAE;IACtC,OAAO,IAAI;EACb;EACA,MAAMvF,KAAK,GAAGuF,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC;EAChC,MAAM5H,MAAM,GAAGsF,UAAU,CAACsC,IAAI,CAAC,CAAC,CAAC;EACjC,IAAI7H,KAAK,KAAK,CAAC,IAAIC,MAAM,KAAK,CAAC,EAAE;IAC/B,OAAO,IAAI;EACb;EACA,MAAMoL,SAAS,GAAGJ,QAAQ,CAACK,WAAW,CAAC/F,UAAU,EAAE,IAAI,CAAC;EACxD,IAAIgG,OAAO;EACX,IAAIF,SAAS,YAAYG,iBAAiB,EAAE;IAC1CD,OAAO,GAAGF,SAAS;EACrB,CAAC,MAAM;IACL,IAAIA,SAAS,EAAE;MACbE,OAAO,GAAGF,SAAS,CAACI,iBAAiB;IACvC;IACA,IAAI,EAAEF,OAAO,YAAYC,iBAAiB,CAAC,EAAE;MAC3C,MAAM,IAAIL,KAAK,CAAC,gCAAgC,GAAGI,OAAO,CAAC;IAC7D;IACA,IAAIA,OAAO,CAACvL,KAAK,KAAKA,KAAK,IAAIuL,OAAO,CAACtL,MAAM,KAAKA,MAAM,EAAE;MACxD,MAAMuK,OAAO,GAAGe,OAAO,CAACd,UAAU,CAAC,IAAI,CAAC;MACxC,OAAOD,OAAO,CAACJ,YAAY,CAAC,CAAC,EAAE,CAAC,EAAEpK,KAAK,EAAEC,MAAM,CAAC;IAClD;EACF;EAEA,IAAI,CAAC8K,aAAa,EAAE;IAClBA,aAAa,GAAG7L,qBAAqB,CAACc,KAAK,EAAEC,MAAM,EAAEoG,SAAS,EAAE;MAC9DqF,kBAAkB,EAAE;IACtB,CAAC,CAAC;EACJ,CAAC,MAAM;IACL,MAAMf,MAAM,GAAGI,aAAa,CAACJ,MAAM;IACnC,IAAIA,MAAM,CAAC3K,KAAK,KAAKA,KAAK,IAAI2K,MAAM,CAAC1K,MAAM,KAAKA,MAAM,EAAE;MACtD8K,aAAa,GAAG7L,qBAAqB,CAACc,KAAK,EAAEC,MAAM,EAAEoG,SAAS,EAAE;QAC9DqF,kBAAkB,EAAE;MACtB,CAAC,CAAC;IACJ,CAAC,MAAM;MACLX,aAAa,CAACY,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE3L,KAAK,EAAEC,MAAM,CAAC;IAC9C;EACF;EACA8K,aAAa,CAACa,SAAS,CAACL,OAAO,EAAE,CAAC,EAAE,CAAC,EAAEvL,KAAK,EAAEC,MAAM,CAAC;EACrD,OAAO8K,aAAa,CAACX,YAAY,CAAC,CAAC,EAAE,CAAC,EAAEpK,KAAK,EAAEC,MAAM,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASyH,mBAAmBA,CAACmE,MAAM,EAAE;EACnC,OAAOA,MAAM,CAACpK,GAAG,CAAC,UAAUuJ,KAAK,EAAE;IACjC,OAAOA,KAAK,CAACc,aAAa,CAAC,CAAC;EAC9B,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAStF,YAAYA,CAACC,OAAO,EAAE;EAC7B,MAAMwD,GAAG,GAAGxD,OAAO,CAACtG,MAAM;EAC1B,MAAM0L,MAAM,GAAG,IAAItL,KAAK,CAAC0J,GAAG,CAAC;EAC7B,KAAK,IAAIlJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkJ,GAAG,EAAE,EAAElJ,CAAC,EAAE;IAC5B8K,MAAM,CAAC9K,CAAC,CAAC,GAAGgL,WAAW,CAACtF,OAAO,CAAC1F,CAAC,CAAC,CAAC;EACrC;EACA,OAAO8K,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASE,WAAWA,CAACC,aAAa,EAAE;EAClC;EACA,IAAIhB,KAAK;EACT,IAAIgB,aAAa,YAAYlN,MAAM,EAAE;IACnC,IAAIkN,aAAa,YAAY/M,UAAU,EAAE;MACvC+L,KAAK,GAAG,IAAIjM,SAAS,CAAC;QAAC6J,MAAM,EAAEoD;MAAa,CAAC,CAAC;IAChD,CAAC,MAAM,IAAIA,aAAa,YAAYnN,WAAW,EAAE;MAC/CmM,KAAK,GAAG,IAAIpM,UAAU,CAAC;QAACgK,MAAM,EAAEoD;MAAa,CAAC,CAAC;IACjD;EACF,CAAC,MAAM;IACLhB,KAAK,GAAGgB,aAAa;EACvB;EACA,OAAOhB,KAAK;AACd;AAEA,eAAepF,YAAY","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}