{"ast":null,"code":"/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, { asImageLike } from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport { apply as applyTransform, compose as composeTransform } from '../../transform.js';\nimport { ascending } from '../../array.js';\nimport { containsCoordinate, createEmpty, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { createOrUpdate as createTileCoord, getKeyZXY } from '../../tilecoord.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(z, x, y, frameState.pixelRatio, frameState.viewState.projection);\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n    const layer = this.getLayer();\n    const coordinate = applyTransform(frameState.pixelToCoordinateTransform, pixel.slice());\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n      const col = Math.floor(tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0]));\n      const row = Math.floor(tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1]));\n      const gutter = Math.round(tilePixelRatio * source.getGutterForProjection(viewState.projection));\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(frameExtent, fromUserExtent(layerState.extent, projection));\n    }\n    const dx = tileResolution * width / 2 / tilePixelRatio;\n    const dy = tileResolution * height / 2 / tilePixelRatio;\n    const canvasExtent = [viewCenter[0] - dx, viewCenter[1] - dy, viewCenter[0] + dx, viewCenter[1] + dy];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, renderExtent, z - 1, tilesByZ, preload - 1);\n      }, 0);\n    }\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      this.renderComplete = false;\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tilesByZ);\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tilesByZ);\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution, tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution]);\n      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (intersects([x, y, x + w, y + h], [clip[0], clip[3], clip[4], clip[7]])) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged = !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n    this.postRender(this.context, frameState);\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = (map, frameState) => {\n      const tileSourceKey = getUid(tileSource);\n      const wantedTiles = frameState.wantedTiles[tileSourceKey];\n      const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n      this.updateCacheSize(tilesCount);\n      this.tileCache_.expireCache();\n    };\n    frameState.postRenderFunctions.push(postRenderFunction);\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(this.tileCache_.highWaterMark, tileCount * 2);\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(/** @type {import(\"../../ImageTile.js\").default} */tile);\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\nexport default CanvasTileLayerRenderer;","map":{"version":3,"names":["CanvasLayerRenderer","DataTile","asImageLike","ImageTile","LRUCache","ReprojDataTile","ReprojTile","TileRange","TileState","apply","applyTransform","compose","composeTransform","ascending","containsCoordinate","createEmpty","equals","getIntersection","getTopLeft","intersects","createOrUpdate","createTileCoord","getKeyZXY","fromUserExtent","getUid","toSize","getCacheKey","sourceKey","z","x","y","addTileToLookup","tilesByZ","tile","Set","set","existing","has","add","removeTileFromLookup","delete","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","CanvasTileLayerRenderer","constructor","tileLayer","options","extentChanged","renderComplete","renderedExtent_","renderedPixelRatio","renderedProjection","renderedRevision","renderedTiles","renderedSourceKey_","renderedSourceRevision_","tempExtent","tempTileRange_","tempTileCoord_","cacheSize","undefined","tileCache_","maxStaleKeys","getTileCache","getOrCreateTile","tileCache","getLayer","tileSource","getSource","cacheKey","getKey","containsKey","get","getTile","pixelRatio","getData","pixel","coordinate","pixelToCoordinateTransform","slice","layerExtent","tileGrid","tilePixelRatio","getTilePixelRatio","getZForResolution","resolution","getMinZoom","tileCoord","getTileCoordForCoordAndZ","getState","LOADED","tileOrigin","getOrigin","tileSize","getTileSize","tileResolution","getResolution","image","getImage","col","Math","floor","row","gutter","round","getGutterForProjection","getImageData","prepareFrame","sourceRevision","getRevision","renderedRevision_","clear","enqueueTiles","initialZ","preload","tileSourceKey","wantedTiles","map","getMapInternal","minZ","max","min","getMaxResolution","getView","getResolutionForZoom","zDirection","tileRange","getTileRangeForExtentAndZ","minX","maxX","minY","maxY","added","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","findStaleTile_","staleKeys","getStaleKeys","i","length","endTransition","findAltTiles_","altZ","getTileRangeForTileCoordAndZ","covered","loaded","renderFrame","target","viewResolution","viewCenter","center","prependStaleKey","frameExtent","prepareContainer","width","context","canvas","height","dx","dy","canvasExtent","getPreload","nextExtent","targetZ","nextResolution","renderExtent","setTimeout","container","uid","time","tileState","EMPTY","alpha","getAlpha","hasStaleTile","animate","coveredByChildren","minZoom","parentZ","coveredByParent","canvasScale","getRenderContext","tempTransform","clipUnrotated","getInterpolate","imageSmoothingEnabled","preRender","zs","Object","keys","Number","sort","currentClip","clips","clipZs","currentZ","currentTilePixelSize","getTilePixelSize","currentResolution","currentScale","originTileCoord","originTileExtent","getTileCoordExtent","origin","tileGutter","xIndex","nextX","yIndex","nextY","w","h","transition","contextSaved","ii","clip","save","beginPath","moveTo","lineTo","push","drawTile","restore","unshift","updateUsedTiles","usedTiles","renderedResolution","postRender","postRenderFunction","tilesCount","updateCacheSize","expireCache","postRenderFunctions","tileCount","highWaterMark","Error","getTileImage","opacity","alphaChanged","globalAlpha","drawImage"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport CanvasLayerRenderer from './Layer.js';\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\n\n/**\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(sourceKey, z, x, y) {\n  return `${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedRevision;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedRevision_) {\n      this.renderedRevision_ = sourceRevision;\n    } else if (this.renderedRevision_ !== sourceRevision) {\n      this.renderedRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(staleKeys[i], z, x, y);\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.get(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.get(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  * maybe skip transition when not fully opaque\n     *  * decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const sourceRevision = tileSource.getRevision();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (\n        (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n        tileState === TileState.EMPTY\n      ) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      this.renderComplete = false;\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedRevision = sourceRevision;\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n    this.renderedProjection = projection;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = (map, frameState) => {\n      const tileSourceKey = getUid(tileSource);\n      const wantedTiles = frameState.wantedTiles[tileSourceKey];\n      const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n      this.updateCacheSize(tilesCount);\n      this.tileCache_.expireCache();\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}