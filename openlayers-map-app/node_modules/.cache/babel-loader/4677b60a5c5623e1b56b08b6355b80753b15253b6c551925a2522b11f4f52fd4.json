{"ast":null,"code":"/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport { BooleanType, ColorType, NumberArrayType, NumberType, SizeType, StringType, newParsingContext } from '../expr/expression.js';\nimport { ShaderBuilder } from './ShaderBuilder.js';\nimport { asArray } from '../color.js';\nimport { buildExpression, getStringNumberEquivalent, stringToGlsl, uniformNameForVariable } from '../expr/gpu.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  return buildExpression(value, expectedType, parsingContext, compilationContext);\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    fract(packedColor[1] / 256.0)\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType || type === SizeType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */`vec${size}`;\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input).split('').reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    let radius = expressionToGlsl(vertContext, style[`${prefix}radius`], NumberType);\n    if (`${prefix}radius2` in style) {\n      const radius2 = expressionToGlsl(vertContext, style[`${prefix}radius2`], NumberType);\n      radius = `max(${radius}, ${radius2})`;\n    }\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(vertContext, style[`${prefix}stroke-width`], NumberType)} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(vertContext, style[`${prefix}scale`], SizeType);\n    builder.setSymbolSizeExpression(`${builder.getSymbolSizeExpression()} * ${scale}`);\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(expressionToGlsl(vertContext, style[`${prefix}displacement`], NumberArrayType));\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType));\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * vec4(1.0, 1.0, 1.0, ${shapeOpacity})`;\n  if (opacity !== null) {\n    result = `${result} * vec4(1.0, 1.0, 1.0, ${opacity})`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  image.crossOrigin = style[`${prefix}cross-origin`] === undefined ? 'anonymous' : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n\n  // the size is provided asynchronously using a uniform\n  uniforms[`u_texture${textureId}_size`] = () => {\n    return image.complete ? [image.width, image.height] : [0, 0];\n  };\n  builder.addUniform(`vec2 u_texture${textureId}_size`);\n  const size = `u_texture${textureId}_size`;\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(style, prefix, context, imageSize, sampleSize) {\n  let offsetExpression = expressionToGlsl(context, style[`${prefix}offset`], NumberArrayType);\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(style, builder, uniforms, vertContext, fragContext) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] = `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['circle-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['circle-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['circle-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['circle-stroke-color'], ColorType);\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(fragContext, style['circle-radius'], NumberType);\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['circle-stroke-width'], NumberType);\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(distanceField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(style, builder, uniforms, vertContext, fragContext) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] = `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] = `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(fragContext, style['shape-fill-color'], ColorType);\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(fragContext, style['shape-stroke-color'], ColorType);\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(fragContext, style['shape-stroke-width'], NumberType);\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(fragContext, style['shape-points'], NumberType);\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n  if (strokeWidth !== null) {\n    radius = `${radius} + ${strokeWidth} * 0.5`;\n  }\n  if ('shape-radius2' in style) {\n    let radius2 = expressionToGlsl(fragContext, style['shape-radius2'], NumberType);\n    if (strokeWidth !== null) {\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\n  } else {\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(shapeField, fillColor, strokeColor, strokeWidth, opacity);\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(style, builder, uniforms, vertContext, fragContext) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * vec4(1.0, 1.0, 1.0, ${expressionToGlsl(fragContext, style['icon-opacity'], NumberType)})`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(style, builder, uniforms, 'icon-', textureId);\n  builder.setSymbolColorExpression(`${color} * texture2D(u_texture${textureId}, v_texCoord)`).setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(`vec2(${expressionToGlsl(vertContext, style['icon-width'], NumberType)}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`);\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(vertContext, style['icon-size'], NumberArrayType);\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(style, 'icon-', vertContext, 'v_quadSizePx', sampleSize);\n    builder.setTextureCoordinateExpression(`(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`);\n  }\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(vertContext, style['icon-anchor'], NumberArrayType);\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\n    }\n    let shiftPx;\n    if (style['icon-anchor-x-units'] === 'pixels' && style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(`${builder.getSymbolOffsetExpression()} + ${offsetPx}`);\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(expressionToGlsl(fragContext, style['stroke-color'], ColorType));\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'stroke-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[`stroke-pattern-size`], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'stroke-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(fragContext, style['stroke-pattern-spacing'], NumberType);\n    }\n    fragContext.functions['sampleStrokePattern'] = `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return texture2D(texture, texCoord);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(`${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`);\n  }\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(expressionToGlsl(vertContext, style['stroke-width'], NumberType));\n  }\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(expressionToGlsl(vertContext, style['stroke-offset'], NumberType));\n  }\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(expressionToGlsl(vertContext, style['stroke-line-cap'], StringType));\n  }\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(expressionToGlsl(vertContext, style['stroke-line-join'], StringType));\n  }\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType));\n  }\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] = `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n    let dashPattern = style['stroke-line-dash'].map(v => expressionToGlsl(fragContext, v, NumberType));\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(vertContext, style['stroke-line-dash-offset'], NumberType);\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n    const dashLengthsDef = dashPattern.map((v, i) => `float dashLength${i} = ${v};`);\n    const totalLengthDef = dashPattern.map((v, i) => `dashLength${i}`).join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${i - 2} + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n    fragContext.functions[dashFunctionName] = `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(`${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`);\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(style, builder, uniforms, vertContext, fragContext) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(expressionToGlsl(fragContext, style['fill-color'], ColorType));\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(style, builder, uniforms, 'fill-pattern-', textureId);\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(fragContext, style[`fill-pattern-size`], NumberArrayType);\n      offsetExpression = parseImageOffsetProperties(style, 'fill-pattern-', fragContext, sizeExpression, sampleSizeExpression);\n    }\n    fragContext.functions['sampleFillPattern'] = `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return texture2D(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(`${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`);\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style\n  };\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(fragContext, style.filter, BooleanType);\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  for (const varName in fragContext.variables) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n    uniforms[uniformName] = () => {\n      const value = style.variables[variable.name];\n      if (typeof value === 'number') {\n        return value;\n      }\n      if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      if (variable.type === ColorType) {\n        return packColor([...asArray(value || '#eee')]);\n      }\n      if (typeof value === 'string') {\n        return getStringNumberEquivalent(value);\n      }\n      return value;\n    };\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  for (const propName in fragContext.properties) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  }\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  for (const propName in vertContext.properties) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(`${getGlslTypeFromType(property.type)} a_prop_${property.name}`);\n  }\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  /**\n   * @type {import('../render/webgl/VectorStyleRenderer.js').AttributeDefinitions}\n   */\n  const attributes = {};\n  for (const propName in vertContext.properties) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else {\n      callback = feature => {\n        const value = feature.get(property.name);\n        if (property.type === ColorType) {\n          return packColor([...asArray(value || '#eee')]);\n        }\n        if (typeof value === 'string') {\n          return getStringNumberEquivalent(value);\n        }\n        if (typeof value === 'boolean') {\n          return value ? 1 : 0;\n        }\n        return value;\n      };\n    }\n    attributes[property.name] = {\n      size: getGlslSizeFromType(property.type),\n      callback\n    };\n  }\n  return {\n    builder,\n    attributes,\n    uniforms\n  };\n}","map":{"version":3,"names":["BooleanType","ColorType","NumberArrayType","NumberType","SizeType","StringType","newParsingContext","ShaderBuilder","asArray","buildExpression","getStringNumberEquivalent","stringToGlsl","uniformNameForVariable","expressionToGlsl","compilationContext","value","expectedType","parsingContext","packColor","color","array","r","g","b","a","Math","round","UNPACK_COLOR_FN","getGlslSizeFromType","type","getGlslTypeFromType","size","computeHash","input","hash","JSON","stringify","split","reduce","prev","curr","charCodeAt","toString","parseCommonSymbolProperties","style","builder","vertContext","prefix","radius","radius2","setSymbolSizeExpression","scale","getSymbolSizeExpression","setSymbolOffsetExpression","setSymbolRotationExpression","setSymbolRotateWithView","getColorFromDistanceField","distanceField","fillColor","strokeColor","strokeWidth","opacity","strokeFillRatio","shapeOpacity","result","parseImageProperties","uniforms","textureId","image","Image","crossOrigin","undefined","src","complete","width","height","addUniform","parseImageOffsetProperties","context","imageSize","sampleSize","offsetExpression","parseCircleProperties","fragContext","functions","currentPoint","colorExpression","setSymbolColorExpression","parseShapeProperties","numPoints","angle","shapeField","parseIconProperties","sizeExpression","fullsize","offset","setTextureCoordinateExpression","anchor","shiftPx","offsetPx","getSymbolOffsetExpression","parseStrokeProperties","setStrokeColorExpression","sampleSizeExpression","spacingExpression","textureName","tintExpression","getStrokeColorExpression","setStrokeWidthExpression","setStrokeOffsetExpression","setStrokeCapExpression","setStrokeJoinExpression","setStrokeMiterLimitExpression","dashPattern","map","v","length","uniqueDashKey","dashFunctionName","dashLengthsDef","i","totalLengthDef","join","currentDashOffset","distanceExpression","setStrokeDistanceFieldExpression","parseFillProperties","setFillColorExpression","getFillColorExpression","parseLiteralStyle","inFragmentShader","properties","variables","filter","parsedFilter","setFragmentDiscardExpression","varName","variable","uniformName","name","propName","property","expression","addVertexShaderFunction","addVarying","addAttribute","functionName","addFragmentShaderFunction","attributes","callback","evaluator","feature","get"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/webgl/styleparser.js"],"sourcesContent":["/**\n * Utilities for parsing literal style objects\n * @module ol/webgl/styleparser\n */\nimport {\n  BooleanType,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  SizeType,\n  StringType,\n  newParsingContext,\n} from '../expr/expression.js';\nimport {ShaderBuilder} from './ShaderBuilder.js';\nimport {asArray} from '../color.js';\nimport {\n  buildExpression,\n  getStringNumberEquivalent,\n  stringToGlsl,\n  uniformNameForVariable,\n} from '../expr/gpu.js';\n\n/**\n * Recursively parses a style expression and outputs a GLSL-compatible string. Takes in a compilation context that\n * will be read and modified during the parsing operation.\n * @param {import(\"../expr/gpu.js\").CompilationContext} compilationContext Compilation context\n * @param {import(\"../expr/expression.js\").EncodedExpression} value Value\n * @param {number} [expectedType] Expected final type (can be several types combined)\n * @return {string} GLSL-compatible output\n */\nexport function expressionToGlsl(compilationContext, value, expectedType) {\n  const parsingContext = newParsingContext();\n  return buildExpression(\n    value,\n    expectedType,\n    parsingContext,\n    compilationContext,\n  );\n}\n\n/**\n * Packs all components of a color into a two-floats array\n * @param {import(\"../color.js\").Color|string} color Color as array of numbers or string\n * @return {Array<number>} Vec2 array containing the color in compressed form\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256;\n  const g = array[1];\n  const b = array[2] * 256;\n  const a = Math.round(array[3] * 255);\n  return [r + g, b + a];\n}\n\nconst UNPACK_COLOR_FN = `vec4 unpackColor(vec2 packedColor) {\n  return vec4(\n    fract(floor(packedColor[0] / 256.0) / 256.0),\n    fract(packedColor[0] / 256.0),\n    fract(floor(packedColor[1] / 256.0) / 256.0),\n    fract(packedColor[1] / 256.0)\n  );\n}`;\n\n/**\n * @param {number} type Value type\n * @return {1|2|3|4} The amount of components for this value\n */\nfunction getGlslSizeFromType(type) {\n  if (type === ColorType || type === SizeType) {\n    return 2;\n  }\n  if (type === NumberArrayType) {\n    return 4;\n  }\n  return 1;\n}\n\n/**\n * @param {number} type Value type\n * @return {'float'|'vec2'|'vec3'|'vec4'} The corresponding GLSL type for this value\n */\nfunction getGlslTypeFromType(type) {\n  const size = getGlslSizeFromType(type);\n  if (size > 1) {\n    return /** @type {'vec2'|'vec3'|'vec4'} */ (`vec${size}`);\n  }\n  return 'float';\n}\n\n/**\n * see https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\n * @param {Object|string} input The hash input, either an object or string\n * @return {string} Hash (if the object cannot be serialized, it is based on `getUid`)\n */\nexport function computeHash(input) {\n  const hash = JSON.stringify(input)\n    .split('')\n    .reduce((prev, curr) => (prev << 5) - prev + curr.charCodeAt(0), 0);\n  return (hash >>> 0).toString();\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {'shape-'|'circle-'|'icon-'} prefix Properties prefix\n */\nfunction parseCommonSymbolProperties(style, builder, vertContext, prefix) {\n  if (`${prefix}radius` in style && prefix !== 'icon-') {\n    let radius = expressionToGlsl(\n      vertContext,\n      style[`${prefix}radius`],\n      NumberType,\n    );\n    if (`${prefix}radius2` in style) {\n      const radius2 = expressionToGlsl(\n        vertContext,\n        style[`${prefix}radius2`],\n        NumberType,\n      );\n      radius = `max(${radius}, ${radius2})`;\n    }\n    if (`${prefix}stroke-width` in style) {\n      radius = `(${radius} + ${expressionToGlsl(\n        vertContext,\n        style[`${prefix}stroke-width`],\n        NumberType,\n      )} * 0.5)`;\n    }\n    builder.setSymbolSizeExpression(`vec2(${radius} * 2. + 0.5)`); // adding some padding for antialiasing\n  }\n  if (`${prefix}scale` in style) {\n    const scale = expressionToGlsl(\n      vertContext,\n      style[`${prefix}scale`],\n      SizeType,\n    );\n    builder.setSymbolSizeExpression(\n      `${builder.getSymbolSizeExpression()} * ${scale}`,\n    );\n  }\n  if (`${prefix}displacement` in style) {\n    builder.setSymbolOffsetExpression(\n      expressionToGlsl(\n        vertContext,\n        style[`${prefix}displacement`],\n        NumberArrayType,\n      ),\n    );\n  }\n  if (`${prefix}rotation` in style) {\n    builder.setSymbolRotationExpression(\n      expressionToGlsl(vertContext, style[`${prefix}rotation`], NumberType),\n    );\n  }\n  if (`${prefix}rotate-with-view` in style) {\n    builder.setSymbolRotateWithView(!!style[`${prefix}rotate-with-view`]);\n  }\n}\n\n/**\n * @param {string} distanceField The distance field expression\n * @param {string|null} fillColor The fill color expression; null if no fill\n * @param {string|null} strokeColor The stroke color expression; null if no stroke\n * @param {string|null} strokeWidth The stroke width expression; null if no stroke\n * @param {string|null} opacity The opacity expression; null if no stroke\n * @return {string} The final color expression, based on the distance field and given params\n */\nfunction getColorFromDistanceField(\n  distanceField,\n  fillColor,\n  strokeColor,\n  strokeWidth,\n  opacity,\n) {\n  let color = 'vec4(0.)';\n  if (fillColor !== null) {\n    color = fillColor;\n  }\n  if (strokeColor !== null && strokeWidth !== null) {\n    const strokeFillRatio = `smoothstep(-${strokeWidth} + 0.63, -${strokeWidth} - 0.58, ${distanceField})`;\n    color = `mix(${strokeColor}, ${color}, ${strokeFillRatio})`;\n  }\n  const shapeOpacity = `(1.0 - smoothstep(-0.63, 0.58, ${distanceField}))`;\n  let result = `${color} * vec4(1.0, 1.0, 1.0, ${shapeOpacity})`;\n  if (opacity !== null) {\n    result = `${result} * vec4(1.0, 1.0, 1.0, ${opacity})`;\n  }\n  return result;\n}\n\n/**\n * This will parse an image property provided by `<prefix>-src`\n * The image size expression in GLSL will be returned\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {string} textureId A identifier that will be used in the generated uniforms: `sample2d u_texture<id>` and `vec2 u_texture<id>_size`\n * @return {string} The image size expression\n */\nfunction parseImageProperties(style, builder, uniforms, prefix, textureId) {\n  const image = new Image();\n  image.crossOrigin =\n    style[`${prefix}cross-origin`] === undefined\n      ? 'anonymous'\n      : style[`${prefix}cross-origin`];\n  image.src = style[`${prefix}src`];\n\n  // the size is provided asynchronously using a uniform\n  uniforms[`u_texture${textureId}_size`] = () => {\n    return image.complete ? [image.width, image.height] : [0, 0];\n  };\n  builder.addUniform(`vec2 u_texture${textureId}_size`);\n  const size = `u_texture${textureId}_size`;\n\n  uniforms[`u_texture${textureId}`] = image;\n  builder.addUniform(`sampler2D u_texture${textureId}`);\n  return size;\n}\n\n/**\n * This will parse an image's offset properties provided by `<prefix>-offset`, `<prefix>-offset-origin` and `<prefix>-size`\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {'icon-'|'fill-pattern-'|'stroke-pattern-'} prefix Property prefix\n * @param {import(\"../expr/gpu.js\").CompilationContext} context Shader compilation context (vertex or fragment)\n * @param {string} imageSize Pixel size of the full image as a GLSL expression\n * @param {string} sampleSize Pixel size of the sample in the image as a GLSL expression\n * @return {string} The offset expression\n */\nfunction parseImageOffsetProperties(\n  style,\n  prefix,\n  context,\n  imageSize,\n  sampleSize,\n) {\n  let offsetExpression = expressionToGlsl(\n    context,\n    style[`${prefix}offset`],\n    NumberArrayType,\n  );\n  if (`${prefix}offset-origin` in style) {\n    switch (style[`${prefix}offset-origin`]) {\n      case 'top-right':\n        offsetExpression = `vec2(${imageSize}.x, 0.) + ${sampleSize} * vec2(-1., 0.) + ${offsetExpression} * vec2(-1., 1.)`;\n        break;\n      case 'bottom-left':\n        offsetExpression = `vec2(0., ${imageSize}.y) + ${sampleSize} * vec2(0., -1.) + ${offsetExpression} * vec2(1., -1.)`;\n        break;\n      case 'bottom-right':\n        offsetExpression = `${imageSize} - ${sampleSize} - ${offsetExpression}`;\n        break;\n      default: // pass\n    }\n  }\n  return offsetExpression;\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseCircleProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // this function takes in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the circle, positive outside, values in pixels)\n  fragContext.functions['circleDistanceField'] =\n    `float circleDistanceField(vec2 point, float radius) {\n  return length(point) - radius;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'circle-');\n\n  // OPACITY\n  let opacity = null;\n  if ('circle-opacity' in style) {\n    opacity = expressionToGlsl(\n      fragContext,\n      style['circle-opacity'],\n      NumberType,\n    );\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('circle-scale' in style) {\n    const scale = expressionToGlsl(\n      fragContext,\n      style['circle-scale'],\n      SizeType,\n    );\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('circle-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['circle-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('circle-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // RADIUS\n  let radius = expressionToGlsl(\n    fragContext,\n    style['circle-radius'],\n    NumberType,\n  );\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('circle-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['circle-stroke-width'],\n      NumberType,\n    );\n    radius = `(${radius} + ${strokeWidth} * 0.5)`;\n  }\n\n  // FINAL COLOR\n  const distanceField = `circleDistanceField(${currentPoint}, ${radius})`;\n  const colorExpression = getColorFromDistanceField(\n    distanceField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseShapeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  fragContext.functions['round'] = `float round(float v) {\n  return sign(v) * floor(abs(v) + 0.5);\n}`;\n\n  // these functions take in screen coordinates in pixels and returns the signed distance field\n  // (0 on the boundary, negative inside the polygon, positive outside, values in pixels)\n  // inspired by https://github.com/zranger1/PixelblazePatterns/blob/master/Toolkit/sdf2d.md#n-sided-regular-polygon\n  fragContext.functions['starDistanceField'] =\n    `float starDistanceField(vec2 point, float numPoints, float radius, float radius2, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round(beta / alpha) * alpha; // angle in sector\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  vec2 tipToPoint = inSector + vec2(-radius, 0.);\n  vec2 edgeNormal = vec2(radius2 * sin(alpha * 0.5), -radius2 * cos(alpha * 0.5) + radius);\n  return dot(normalize(edgeNormal), tipToPoint);\n}`;\n  fragContext.functions['regularDistanceField'] =\n    `float regularDistanceField(vec2 point, float numPoints, float radius, float angle) {\n  float startAngle = -PI * 0.5 + angle; // tip starts upwards and rotates clockwise with angle\n  float c = cos(startAngle);\n  float s = sin(startAngle);\n  vec2 pointRotated = vec2(c * point.x - s * point.y, s * point.x + c * point.y);\n  float alpha = TWO_PI / numPoints; // the angle of one sector\n  float radiusIn = radius * cos(PI / numPoints);\n  float beta = atan(pointRotated.y, pointRotated.x);\n  float gamma = round((beta - alpha * 0.5) / alpha) * alpha + alpha * 0.5; // angle in sector from mid\n  c = cos(-gamma);\n  s = sin(-gamma);\n  vec2 inSector = vec2(c * pointRotated.x - s * pointRotated.y, abs(s * pointRotated.x + c * pointRotated.y));\n  return inSector.x - radiusIn;\n}`;\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'shape-');\n\n  // OPACITY\n  let opacity = null;\n  if ('shape-opacity' in style) {\n    opacity = expressionToGlsl(fragContext, style['shape-opacity'], NumberType);\n  }\n\n  // SCALE\n  let currentPoint = 'coordsPx';\n  if ('shape-scale' in style) {\n    const scale = expressionToGlsl(fragContext, style['shape-scale'], SizeType);\n    currentPoint = `coordsPx / ${scale}`;\n  }\n\n  // FILL COLOR\n  let fillColor = null;\n  if ('shape-fill-color' in style) {\n    fillColor = expressionToGlsl(\n      fragContext,\n      style['shape-fill-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE COLOR\n  let strokeColor = null;\n  if ('shape-stroke-color' in style) {\n    strokeColor = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-color'],\n      ColorType,\n    );\n  }\n\n  // STROKE WIDTH\n  let strokeWidth = null;\n  if ('shape-stroke-width' in style) {\n    strokeWidth = expressionToGlsl(\n      fragContext,\n      style['shape-stroke-width'],\n      NumberType,\n    );\n  }\n\n  // SHAPE TYPE\n  const numPoints = expressionToGlsl(\n    fragContext,\n    style['shape-points'],\n    NumberType,\n  );\n  let angle = '0.';\n  if ('shape-angle' in style) {\n    angle = expressionToGlsl(fragContext, style['shape-angle'], NumberType);\n  }\n  let shapeField;\n  let radius = expressionToGlsl(fragContext, style['shape-radius'], NumberType);\n  if (strokeWidth !== null) {\n    radius = `${radius} + ${strokeWidth} * 0.5`;\n  }\n  if ('shape-radius2' in style) {\n    let radius2 = expressionToGlsl(\n      fragContext,\n      style['shape-radius2'],\n      NumberType,\n    );\n    if (strokeWidth !== null) {\n      radius2 = `${radius2} + ${strokeWidth} * 0.5`;\n    }\n    shapeField = `starDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${radius2}, ${angle})`;\n  } else {\n    shapeField = `regularDistanceField(${currentPoint}, ${numPoints}, ${radius}, ${angle})`;\n  }\n\n  // FINAL COLOR\n  const colorExpression = getColorFromDistanceField(\n    shapeField,\n    fillColor,\n    strokeColor,\n    strokeWidth,\n    opacity,\n  );\n  builder.setSymbolColorExpression(colorExpression);\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseIconProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  // COLOR\n  let color = 'vec4(1.0)';\n  if ('icon-color' in style) {\n    color = expressionToGlsl(fragContext, style['icon-color'], ColorType);\n  }\n\n  // OPACITY\n  if ('icon-opacity' in style) {\n    color = `${color} * vec4(1.0, 1.0, 1.0, ${expressionToGlsl(\n      fragContext,\n      style['icon-opacity'],\n      NumberType,\n    )})`;\n  }\n\n  // IMAGE & SIZE\n  const textureId = computeHash(style['icon-src']);\n  const sizeExpression = parseImageProperties(\n    style,\n    builder,\n    uniforms,\n    'icon-',\n    textureId,\n  );\n  builder\n    .setSymbolColorExpression(\n      `${color} * texture2D(u_texture${textureId}, v_texCoord)`,\n    )\n    .setSymbolSizeExpression(sizeExpression);\n\n  // override size if width/height were specified\n  if ('icon-width' in style && 'icon-height' in style) {\n    builder.setSymbolSizeExpression(\n      `vec2(${expressionToGlsl(\n        vertContext,\n        style['icon-width'],\n        NumberType,\n      )}, ${expressionToGlsl(vertContext, style['icon-height'], NumberType)})`,\n    );\n  }\n\n  // tex coord\n  if ('icon-offset' in style && 'icon-size' in style) {\n    const sampleSize = expressionToGlsl(\n      vertContext,\n      style['icon-size'],\n      NumberArrayType,\n    );\n    const fullsize = builder.getSymbolSizeExpression();\n    builder.setSymbolSizeExpression(sampleSize);\n    const offset = parseImageOffsetProperties(\n      style,\n      'icon-',\n      vertContext,\n      'v_quadSizePx',\n      sampleSize,\n    );\n    builder.setTextureCoordinateExpression(\n      `(vec4((${offset}).xyxy) + vec4(0., 0., ${sampleSize})) / (${fullsize}).xyxy`,\n    );\n  }\n\n  parseCommonSymbolProperties(style, builder, vertContext, 'icon-');\n\n  if ('icon-anchor' in style) {\n    const anchor = expressionToGlsl(\n      vertContext,\n      style['icon-anchor'],\n      NumberArrayType,\n    );\n    let scale = `1.0`;\n    if (`icon-scale` in style) {\n      scale = expressionToGlsl(vertContext, style[`icon-scale`], SizeType);\n    }\n    let shiftPx;\n    if (\n      style['icon-anchor-x-units'] === 'pixels' &&\n      style['icon-anchor-y-units'] === 'pixels'\n    ) {\n      shiftPx = `${anchor} * ${scale}`;\n    } else if (style['icon-anchor-x-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(vec2(${scale}).x, v_quadSizePx.y)`;\n    } else if (style['icon-anchor-y-units'] === 'pixels') {\n      shiftPx = `${anchor} * vec2(v_quadSizePx.x, vec2(${scale}).x)`;\n    } else {\n      shiftPx = `${anchor} * v_quadSizePx`;\n    }\n    // default origin is top-left\n    let offsetPx = `v_quadSizePx * vec2(0.5, -0.5) + ${shiftPx} * vec2(-1., 1.)`;\n    if ('icon-anchor-origin' in style) {\n      switch (style['icon-anchor-origin']) {\n        case 'top-right':\n          offsetPx = `v_quadSizePx * -0.5 + ${shiftPx}`;\n          break;\n        case 'bottom-left':\n          offsetPx = `v_quadSizePx * 0.5 - ${shiftPx}`;\n          break;\n        case 'bottom-right':\n          offsetPx = `v_quadSizePx * vec2(-0.5, 0.5) + ${shiftPx} * vec2(1., -1.)`;\n          break;\n        default: // pass\n      }\n    }\n    builder.setSymbolOffsetExpression(\n      `${builder.getSymbolOffsetExpression()} + ${offsetPx}`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseStrokeProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('stroke-color' in style) {\n    builder.setStrokeColorExpression(\n      expressionToGlsl(fragContext, style['stroke-color'], ColorType),\n    );\n  }\n  if ('stroke-pattern-src' in style) {\n    const textureId = computeHash(style['stroke-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'stroke-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('stroke-pattern-offset' in style && 'stroke-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`stroke-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'stroke-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    let spacingExpression = '0.';\n    if ('stroke-pattern-spacing' in style) {\n      spacingExpression = expressionToGlsl(\n        fragContext,\n        style['stroke-pattern-spacing'],\n        NumberType,\n      );\n    }\n    fragContext.functions['sampleStrokePattern'] =\n      `vec4 sampleStrokePattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, float spacingPx, float currentLengthPx, float currentRadiusRatio, float lineWidth) {\n  float currentLengthScaled = currentLengthPx * sampleSize.y / lineWidth;\n  float spacingScaled = spacingPx * sampleSize.y / lineWidth;\n  float uCoordPx = mod(currentLengthScaled, (sampleSize.x + spacingScaled));\n  // make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  uCoordPx = clamp(uCoordPx, 0.5, sampleSize.x - 0.5);\n  float vCoordPx = (-currentRadiusRatio * 0.5 + 0.5) * sampleSize.y;\n  vec2 texCoord = (vec2(uCoordPx, vCoordPx) + textureOffset) / textureSize;\n  return texture2D(texture, texCoord);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('stroke-color' in style) {\n      tintExpression = builder.getStrokeColorExpression();\n    }\n    builder.setStrokeColorExpression(\n      `${tintExpression} * sampleStrokePattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, ${spacingExpression}, currentLengthPx, currentRadiusRatio, v_width)`,\n    );\n  }\n\n  if ('stroke-width' in style) {\n    builder.setStrokeWidthExpression(\n      expressionToGlsl(vertContext, style['stroke-width'], NumberType),\n    );\n  }\n\n  if ('stroke-offset' in style) {\n    builder.setStrokeOffsetExpression(\n      expressionToGlsl(vertContext, style['stroke-offset'], NumberType),\n    );\n  }\n\n  if ('stroke-line-cap' in style) {\n    builder.setStrokeCapExpression(\n      expressionToGlsl(vertContext, style['stroke-line-cap'], StringType),\n    );\n  }\n\n  if ('stroke-line-join' in style) {\n    builder.setStrokeJoinExpression(\n      expressionToGlsl(vertContext, style['stroke-line-join'], StringType),\n    );\n  }\n\n  if ('stroke-miter-limit' in style) {\n    builder.setStrokeMiterLimitExpression(\n      expressionToGlsl(vertContext, style['stroke-miter-limit'], NumberType),\n    );\n  }\n\n  if ('stroke-line-dash' in style) {\n    fragContext.functions['getSingleDashDistance'] =\n      `float getSingleDashDistance(float distance, float radius, float dashOffset, float dashLength, float dashLengthTotal, float capType) {\n  float localDistance = mod(distance, dashLengthTotal);\n  float distanceSegment = abs(localDistance - dashOffset - dashLength * 0.5) - dashLength * 0.5;\n  distanceSegment = min(distanceSegment, dashLengthTotal - localDistance);\n  if (capType == ${stringToGlsl('square')}) {\n    distanceSegment -= v_width * 0.5;\n  } else if (capType == ${stringToGlsl('round')}) {\n    distanceSegment = min(distanceSegment, sqrt(distanceSegment * distanceSegment + radius * radius) - v_width * 0.5);\n  }\n  return distanceSegment;\n}`;\n\n    let dashPattern = style['stroke-line-dash'].map((v) =>\n      expressionToGlsl(fragContext, v, NumberType),\n    );\n    // if pattern has odd length, concatenate it with itself to be even\n    if (dashPattern.length % 2 === 1) {\n      dashPattern = [...dashPattern, ...dashPattern];\n    }\n\n    let offsetExpression = '0.';\n    if ('stroke-line-dash-offset' in style) {\n      offsetExpression = expressionToGlsl(\n        vertContext,\n        style['stroke-line-dash-offset'],\n        NumberType,\n      );\n    }\n\n    // define a function for this dash specifically\n    const uniqueDashKey = computeHash(style['stroke-line-dash']);\n    const dashFunctionName = `dashDistanceField_${uniqueDashKey}`;\n\n    const dashLengthsDef = dashPattern.map(\n      (v, i) => `float dashLength${i} = ${v};`,\n    );\n    const totalLengthDef = dashPattern\n      .map((v, i) => `dashLength${i}`)\n      .join(' + ');\n    let currentDashOffset = '0.';\n    let distanceExpression = `getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength0, totalDashLength, capType)`;\n    for (let i = 2; i < dashPattern.length; i += 2) {\n      currentDashOffset = `${currentDashOffset} + dashLength${\n        i - 2\n      } + dashLength${i - 1}`;\n      distanceExpression = `min(${distanceExpression}, getSingleDashDistance(distance, radius, ${currentDashOffset}, dashLength${i}, totalDashLength, capType))`;\n    }\n\n    fragContext.functions[dashFunctionName] =\n      `float ${dashFunctionName}(float distance, float radius, float capType) {\n  ${dashLengthsDef.join('\\n  ')}\n  float totalDashLength = ${totalLengthDef};\n  return ${distanceExpression};\n}`;\n    builder.setStrokeDistanceFieldExpression(\n      `${dashFunctionName}(currentLengthPx + ${offsetExpression}, currentRadiusPx, capType)`,\n    );\n  }\n}\n\n/**\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Style\n * @param {ShaderBuilder} builder Shader Builder\n * @param {Object<string,import(\"../webgl/Helper\").UniformValue>} uniforms Uniforms\n * @param {import(\"../expr/gpu.js\").CompilationContext} vertContext Vertex shader compilation context\n * @param {import(\"../expr/gpu.js\").CompilationContext} fragContext Fragment shader compilation context\n */\nfunction parseFillProperties(\n  style,\n  builder,\n  uniforms,\n  vertContext,\n  fragContext,\n) {\n  if ('fill-color' in style) {\n    builder.setFillColorExpression(\n      expressionToGlsl(fragContext, style['fill-color'], ColorType),\n    );\n  }\n  if ('fill-pattern-src' in style) {\n    const textureId = computeHash(style['fill-pattern-src']);\n    const sizeExpression = parseImageProperties(\n      style,\n      builder,\n      uniforms,\n      'fill-pattern-',\n      textureId,\n    );\n    let sampleSizeExpression = sizeExpression;\n    let offsetExpression = 'vec2(0.)';\n    if ('fill-pattern-offset' in style && 'fill-pattern-size' in style) {\n      sampleSizeExpression = expressionToGlsl(\n        fragContext,\n        style[`fill-pattern-size`],\n        NumberArrayType,\n      );\n      offsetExpression = parseImageOffsetProperties(\n        style,\n        'fill-pattern-',\n        fragContext,\n        sizeExpression,\n        sampleSizeExpression,\n      );\n    }\n    fragContext.functions['sampleFillPattern'] =\n      `vec4 sampleFillPattern(sampler2D texture, vec2 textureSize, vec2 textureOffset, vec2 sampleSize, vec2 pxOrigin, vec2 pxPosition) {\n  float scaleRatio = pow(2., mod(u_zoom + 0.5, 1.) - 0.5);\n  vec2 pxRelativePos = pxPosition - pxOrigin;\n  // rotate the relative position from origin by the current view rotation\n  pxRelativePos = vec2(pxRelativePos.x * cos(u_rotation) - pxRelativePos.y * sin(u_rotation), pxRelativePos.x * sin(u_rotation) + pxRelativePos.y * cos(u_rotation));\n  // sample position is computed according to the sample offset & size\n  vec2 samplePos = mod(pxRelativePos / scaleRatio, sampleSize);\n  // also make sure that we're not sampling too close to the borders to avoid interpolation with outside pixels\n  samplePos = clamp(samplePos, vec2(0.5), sampleSize - vec2(0.5));\n  samplePos.y = sampleSize.y - samplePos.y; // invert y axis so that images appear upright\n  return texture2D(texture, (samplePos + textureOffset) / textureSize);\n}`;\n    const textureName = `u_texture${textureId}`;\n    let tintExpression = '1.';\n    if ('fill-color' in style) {\n      tintExpression = builder.getFillColorExpression();\n    }\n    builder.setFillColorExpression(\n      `${tintExpression} * sampleFillPattern(${textureName}, ${sizeExpression}, ${offsetExpression}, ${sampleSizeExpression}, pxOrigin, pxPos)`,\n    );\n  }\n}\n\n/**\n * @typedef {Object} StyleParseResult\n * @property {ShaderBuilder} builder Shader builder pre-configured according to a given style\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").UniformDefinitions} uniforms Uniform definitions\n * @property {import(\"../render/webgl/VectorStyleRenderer.js\").AttributeDefinitions} attributes Attribute definitions\n */\n\n/**\n * Parses a {@link import(\"../style/webgl.js\").WebGLStyle} object and returns a {@link ShaderBuilder}\n * object that has been configured according to the given style, as well as `attributes` and `uniforms`\n * arrays to be fed to the `WebGLPointsRenderer` class.\n *\n * Also returns `uniforms` and `attributes` properties as expected by the\n * {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n * @param {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n * @return {StyleParseResult} Result containing shader params, attributes and uniforms.\n */\nexport function parseLiteralStyle(style) {\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const vertContext = {\n    inFragmentShader: false,\n    properties: {},\n    variables: {},\n    functions: {},\n    style,\n  };\n\n  /**\n   * @type {import(\"../expr/gpu.js\").CompilationContext}\n   */\n  const fragContext = {\n    inFragmentShader: true,\n    variables: vertContext.variables,\n    properties: {},\n    functions: {},\n    style,\n  };\n\n  const builder = new ShaderBuilder();\n\n  /** @type {Object<string,import(\"../webgl/Helper\").UniformValue>} */\n  const uniforms = {};\n\n  if ('icon-src' in style) {\n    parseIconProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('shape-points' in style) {\n    parseShapeProperties(style, builder, uniforms, vertContext, fragContext);\n  } else if ('circle-radius' in style) {\n    parseCircleProperties(style, builder, uniforms, vertContext, fragContext);\n  }\n  parseStrokeProperties(style, builder, uniforms, vertContext, fragContext);\n  parseFillProperties(style, builder, uniforms, vertContext, fragContext);\n\n  if (style.filter) {\n    const parsedFilter = expressionToGlsl(\n      fragContext,\n      style.filter,\n      BooleanType,\n    );\n    builder.setFragmentDiscardExpression(`!${parsedFilter}`);\n  }\n\n  // define one uniform per variable\n  for (const varName in fragContext.variables) {\n    const variable = fragContext.variables[varName];\n    const uniformName = uniformNameForVariable(variable.name);\n    builder.addUniform(`${getGlslTypeFromType(variable.type)} ${uniformName}`);\n\n    uniforms[uniformName] = () => {\n      const value = style.variables[variable.name];\n      if (typeof value === 'number') {\n        return value;\n      }\n      if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      }\n      if (variable.type === ColorType) {\n        return packColor([...asArray(value || '#eee')]);\n      }\n      if (typeof value === 'string') {\n        return getStringNumberEquivalent(value);\n      }\n      return value;\n    };\n  }\n\n  // for each feature attribute used in the fragment shader, define a varying that will be used to pass data\n  // from the vertex to the fragment shader, as well as an attribute in the vertex shader (if not already present)\n  for (const propName in fragContext.properties) {\n    const property = fragContext.properties[propName];\n    if (!vertContext.properties[propName]) {\n      vertContext.properties[propName] = property;\n    }\n    let type = getGlslTypeFromType(property.type);\n    let expression = `a_prop_${property.name}`;\n    if (property.type === ColorType) {\n      type = 'vec4';\n      expression = `unpackColor(${expression})`;\n      builder.addVertexShaderFunction(UNPACK_COLOR_FN);\n    }\n    builder.addVarying(`v_prop_${property.name}`, type, expression);\n  }\n\n  // for each feature attribute used in the vertex shader, define an attribute in the vertex shader.\n  for (const propName in vertContext.properties) {\n    const property = vertContext.properties[propName];\n    builder.addAttribute(\n      `${getGlslTypeFromType(property.type)} a_prop_${property.name}`,\n    );\n  }\n\n  // add functions that were collected in the compilation contexts\n  for (const functionName in vertContext.functions) {\n    builder.addVertexShaderFunction(vertContext.functions[functionName]);\n  }\n  for (const functionName in fragContext.functions) {\n    builder.addFragmentShaderFunction(fragContext.functions[functionName]);\n  }\n\n  /**\n   * @type {import('../render/webgl/VectorStyleRenderer.js').AttributeDefinitions}\n   */\n  const attributes = {};\n  for (const propName in vertContext.properties) {\n    const property = vertContext.properties[propName];\n    let callback;\n    if (property.evaluator) {\n      callback = property.evaluator;\n    } else {\n      callback = (feature) => {\n        const value = feature.get(property.name);\n        if (property.type === ColorType) {\n          return packColor([...asArray(value || '#eee')]);\n        }\n        if (typeof value === 'string') {\n          return getStringNumberEquivalent(value);\n        }\n        if (typeof value === 'boolean') {\n          return value ? 1 : 0;\n        }\n        return value;\n      };\n    }\n\n    attributes[property.name] = {\n      size: getGlslSizeFromType(property.type),\n      callback,\n    };\n  }\n\n  return {builder, attributes, uniforms};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}