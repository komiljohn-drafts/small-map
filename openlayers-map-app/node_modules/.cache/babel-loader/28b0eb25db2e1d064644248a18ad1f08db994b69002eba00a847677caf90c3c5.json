{"ast":null,"code":"/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileCache from '../TileCache.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, { TileSourceEvent } from './Tile.js';\nimport TileState from '../TileState.js';\nimport { createXYZ, extentFromProjection, getForProjection as getTileGridForProjection } from '../tilegrid.js';\nimport { equivalent, get as getProjection } from '../proj.js';\nimport { getKeyZXY } from '../tilecoord.js';\nimport { getUid } from '../util.js';\nimport { toPromise } from '../functions.js';\nimport { toSize } from '../size.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection = options.projection === undefined ? 'EPSG:3857' : options.projection;\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize\n      });\n    }\n    super({\n      cacheSize: 0.1,\n      // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\n     */\n    this.tileCacheForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.gutter_;\n    }\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const cache = this.getTileCacheForProjection(targetProj);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (cache.containsKey(tileCoordKey)) {\n      const tile = cache.get(tileCoordKey);\n      if (tile && tile.key == this.getKey()) {\n        return tile;\n      }\n    }\n    const tileGrid = this.getTileGrid();\n    const reprojTilePixelRatio = Math.max.apply(null, tileGrid.getResolutions().map((r, z) => {\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const textureSize = this.getTileSize(z);\n      return Math.max(textureSize[0] / tileSize[0], textureSize[1] / tileSize[1]);\n    }));\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, targetProj);\n    const options = Object.assign({\n      sourceProj,\n      sourceTileGrid,\n      targetProj,\n      targetTileGrid,\n      tileCoord,\n      wrappedTileCoord,\n      pixelRatio: reprojTilePixelRatio,\n      gutter: this.getGutterForProjection(sourceProj),\n      getTileFunction: (z, x, y, pixelRatio) => this.getTile(z, x, y, pixelRatio, sourceProj)\n    }, /** @type {import(\"../reproj/DataTile.js\").Options} */this.tileOptions);\n    const newTile = /** @type {TileType} */\n    /** @type {*} */new ReprojDataTile(options);\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (sourceProjection && projection && !equivalent(sourceProjection, projection)) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n    const size = this.getTileSize(z);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    }\n    const sourceLoader = this.loader_;\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_\n    };\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign({\n      tileCoord: [z, x, y],\n      loader: loader,\n      size: size,\n      controller: controller\n    }, this.tileOptions);\n    const tile = /** @type {TileType} */\n    /** @type {*} */new DataTile(options);\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */event.target;\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] = getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @override\n   */\n  getTileCacheForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    }\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileCacheForProjection_)) {\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\n    }\n    return this.tileCacheForProjection_[projKey];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   * @override\n   */\n  expireCache(projection, usedTiles) {\n    const usedTileCache = this.getTileCacheForProjection(projection);\n    this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});\n    for (const id in this.tileCacheForProjection_) {\n      const tileCache = this.tileCacheForProjection_[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  /**\n   * @override\n   */\n  clear() {\n    super.clear();\n    for (const id in this.tileCacheForProjection_) {\n      this.tileCacheForProjection_[id].clear();\n    }\n  }\n}\nexport default DataTileSource;","map":{"version":3,"names":["DataTile","EventType","ReprojDataTile","TileCache","TileEventType","TileSource","TileSourceEvent","TileState","createXYZ","extentFromProjection","getForProjection","getTileGridForProjection","equivalent","get","getProjection","getKeyZXY","getUid","toPromise","toSize","DataTileSource","constructor","options","projection","undefined","tileGrid","extent","maxResolution","maxZoom","minZoom","tileSize","cacheSize","attributions","attributionsCollapsible","state","wrapX","transition","interpolate","key","gutter_","gutter","tileSize_","tileSizes_","tileLoadingKeys_","loader_","loader","handleTileChange_","bind","bandCount","tileGridForProjection_","tileCacheForProjection_","crossOrigin_","crossOrigin","setTileSizes","tileSizes","getTileSize","z","getTileGrid","getGutterForProjection","thisProj","setLoader","getReprojTile_","x","y","targetProj","sourceProj","cache","getTileCacheForProjection","tileCoordKey","containsKey","tile","getKey","reprojTilePixelRatio","Math","max","apply","getResolutions","map","r","textureSize","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","getTileCoordForTileUrlFunction","Object","assign","pixelRatio","getTileFunction","getTile","tileOptions","newTile","sourceProjection","size","tileCache","sourceLoader","controller","AbortController","loaderOptions","signal","requestZ","requestX","requestY","addEventListener","CHANGE","set","event","target","uid","tileState","getState","type","LOADING","TILELOADSTART","ERROR","TILELOADERROR","LOADED","TILELOADEND","dispatchEvent","projKey","setTileGridForProjection","tilegrid","proj","expireCache","usedTiles","usedTileCache","id","clear"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/source/DataTile.js"],"sourcesContent":["/**\n * @module ol/source/DataTile\n */\nimport DataTile from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ReprojDataTile from '../reproj/DataTile.js';\nimport TileCache from '../TileCache.js';\nimport TileEventType from './TileEventType.js';\nimport TileSource, {TileSourceEvent} from './Tile.js';\nimport TileState from '../TileState.js';\nimport {\n  createXYZ,\n  extentFromProjection,\n  getForProjection as getTileGridForProjection,\n} from '../tilegrid.js';\nimport {equivalent, get as getProjection} from '../proj.js';\nimport {getKeyZXY} from '../tilecoord.js';\nimport {getUid} from '../util.js';\nimport {toPromise} from '../functions.js';\nimport {toSize} from '../size.js';\n\n/**\n * @typedef {'anonymous'|'use-credentials'} CrossOriginAttribute\n */\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {AbortSignal} signal An abort controller signal.\n * @property {CrossOriginAttribute} [crossOrigin] The cross-origin attribute for images.\n * @property {number} [maxY] The maximum y coordinate at the given z level.  Will be undefined if the\n * underlying tile grid does not have a known extent.\n */\n\n/**\n * Data tile loading function.  The function is called with z, x, and y tile coordinates and\n * returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * @typedef {function(number, number, number, LoaderOptions) : (import(\"../DataTile.js\").Data|Promise<import(\"../DataTile.js\").Data>)} Loader\n */\n\n/**\n * @typedef {Object} Options\n * @property {Loader} [loader] Data loader.  Called with z, x, and y tile coordinates.\n * Returns {@link import(\"../DataTile.js\").Data data} for a tile or a promise for the same.\n * For loaders that generate images, the promise should not resolve until the image is loaded.\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.\n * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.\n * @property {number|import(\"../size.js\").Size} [tileSize=[256, 256]] The pixel width and height of the source tiles.\n * This may be different than the rendered pixel size if a `tileGrid` is provided.\n * @property {number} [gutter=0] The size in pixels of the gutter around data tiles to ignore.\n * This allows artifacts of rendering at tile edges to be ignored.\n * Supported data should be wider and taller than the tile size by a value of `2 x gutter`.\n * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.\n * @property {import(\"../proj.js\").ProjectionLike} [projection='EPSG:3857'] Tile projection.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid.\n * @property {import(\"./Source.js\").State} [state] The source state.\n * @property {boolean} [wrapX=false] Render tiles beyond the antimeridian.\n * @property {number} [transition] Transition time when fading in new tiles (in milliseconds).\n * @property {number} [bandCount=4] Number of bands represented in the data.\n * @property {boolean} [interpolate=false] Use interpolated values when resampling.  By default,\n * the nearest neighbor is used when resampling.\n * @property {CrossOriginAttribute} [crossOrigin='anonymous'] The crossOrigin property to pass to loaders for image data.\n * @property {string} [key] Key for use in caching tiles.\n */\n\n/**\n * @classdesc\n * A source for typed array data tiles.\n *\n * @fires import(\"./Tile.js\").TileSourceEvent\n * @template {import(\"../Tile.js\").default} [TileType=DataTile]\n * @extends TileSource<TileType>\n * @api\n */\nclass DataTileSource extends TileSource {\n  /**\n   * @param {Options} options DataTile source options.\n   */\n  constructor(options) {\n    const projection =\n      options.projection === undefined ? 'EPSG:3857' : options.projection;\n\n    let tileGrid = options.tileGrid;\n    if (tileGrid === undefined && projection) {\n      tileGrid = createXYZ({\n        extent: extentFromProjection(projection),\n        maxResolution: options.maxResolution,\n        maxZoom: options.maxZoom,\n        minZoom: options.minZoom,\n        tileSize: options.tileSize,\n      });\n    }\n\n    super({\n      cacheSize: 0.1, // don't cache on the source\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      projection: projection,\n      tileGrid: tileGrid,\n      state: options.state,\n      wrapX: options.wrapX,\n      transition: options.transition,\n      interpolate: options.interpolate,\n      key: options.key,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {import('../size.js').Size|null}\n     */\n    this.tileSize_ = options.tileSize ? toSize(options.tileSize) : null;\n\n    /**\n     * @private\n     * @type {Array<import('../size.js').Size>|null}\n     */\n    this.tileSizes_ = null;\n\n    /**\n     * @private\n     * @type {!Object<string, boolean>}\n     */\n    this.tileLoadingKeys_ = {};\n\n    /**\n     * @private\n     */\n    this.loader_ = options.loader;\n\n    /**\n     * @private\n     */\n    this.handleTileChange_ = this.handleTileChange_.bind(this);\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = options.bandCount === undefined ? 4 : options.bandCount; // assume RGBA if undefined\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../tilegrid/TileGrid.js\").default>}\n     */\n    this.tileGridForProjection_ = {};\n\n    /**\n     * @private\n     * @type {!Object<string, import(\"../TileCache.js\").default>}\n     */\n    this.tileCacheForProjection_ = {};\n\n    /**\n     * @private\n     * @type {CrossOriginAttribute}\n     */\n    this.crossOrigin_ = options.crossOrigin || 'anonymous';\n  }\n\n  /**\n   * Set the source tile sizes.  The length of the array is expected to match the number of\n   * levels in the tile grid.\n   * @protected\n   * @param {Array<import('../size.js').Size>} tileSizes An array of tile sizes.\n   */\n  setTileSizes(tileSizes) {\n    this.tileSizes_ = tileSizes;\n  }\n\n  /**\n   * Get the source tile size at the given zoom level.  This may be different than the rendered tile\n   * size.\n   * @protected\n   * @param {number} z Tile zoom level.\n   * @return {import('../size.js').Size} The source tile size.\n   */\n  getTileSize(z) {\n    if (this.tileSizes_) {\n      return this.tileSizes_[z];\n    }\n    if (this.tileSize_) {\n      return this.tileSize_;\n    }\n    const tileGrid = this.getTileGrid();\n    return tileGrid ? toSize(tileGrid.getTileSize(z)) : [256, 256];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {number} Gutter.\n   * @override\n   */\n  getGutterForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.gutter_;\n    }\n\n    return 0;\n  }\n\n  /**\n   * @param {Loader} loader The data loader.\n   * @protected\n   */\n  setLoader(loader) {\n    this.loader_ = loader;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../proj/Projection.js\").default} targetProj The output projection.\n   * @param {import(\"../proj/Projection.js\").default} sourceProj The input projection.\n   * @return {!TileType} Tile.\n   */\n  getReprojTile_(z, x, y, targetProj, sourceProj) {\n    const cache = this.getTileCacheForProjection(targetProj);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (cache.containsKey(tileCoordKey)) {\n      const tile = cache.get(tileCoordKey);\n      if (tile && tile.key == this.getKey()) {\n        return tile;\n      }\n    }\n\n    const tileGrid = this.getTileGrid();\n    const reprojTilePixelRatio = Math.max.apply(\n      null,\n      tileGrid.getResolutions().map((r, z) => {\n        const tileSize = toSize(tileGrid.getTileSize(z));\n        const textureSize = this.getTileSize(z);\n        return Math.max(\n          textureSize[0] / tileSize[0],\n          textureSize[1] / tileSize[1],\n        );\n      }),\n    );\n\n    const sourceTileGrid = this.getTileGridForProjection(sourceProj);\n    const targetTileGrid = this.getTileGridForProjection(targetProj);\n    const tileCoord = [z, x, y];\n    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(\n      tileCoord,\n      targetProj,\n    );\n\n    const options = Object.assign(\n      {\n        sourceProj,\n        sourceTileGrid,\n        targetProj,\n        targetTileGrid,\n        tileCoord,\n        wrappedTileCoord,\n        pixelRatio: reprojTilePixelRatio,\n        gutter: this.getGutterForProjection(sourceProj),\n        getTileFunction: (z, x, y, pixelRatio) =>\n          this.getTile(z, x, y, pixelRatio, sourceProj),\n      },\n      /** @type {import(\"../reproj/DataTile.js\").Options} */ (this.tileOptions),\n    );\n    const newTile = /** @type {TileType} */ (\n      /** @type {*} */ (new ReprojDataTile(options))\n    );\n    newTile.key = this.getKey();\n    return newTile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {TileType|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      sourceProjection &&\n      projection &&\n      !equivalent(sourceProjection, projection)\n    ) {\n      return this.getReprojTile_(z, x, y, projection, sourceProjection);\n    }\n\n    const size = this.getTileSize(z);\n    const tileCoordKey = getKeyZXY(z, x, y);\n    if (this.tileCache.containsKey(tileCoordKey)) {\n      return this.tileCache.get(tileCoordKey);\n    }\n\n    const sourceLoader = this.loader_;\n\n    const controller = new AbortController();\n\n    /**\n     * @type {LoaderOptions}\n     */\n    const loaderOptions = {\n      signal: controller.signal,\n      crossOrigin: this.crossOrigin_,\n    };\n\n    const tileCoord = this.getTileCoordForTileUrlFunction([z, x, y]);\n    if (!tileCoord) {\n      return null;\n    }\n\n    const requestZ = tileCoord[0];\n    const requestX = tileCoord[1];\n    const requestY = tileCoord[2];\n    function loader() {\n      return toPromise(function () {\n        return sourceLoader(requestZ, requestX, requestY, loaderOptions);\n      });\n    }\n\n    /**\n     * @type {import(\"../DataTile.js\").Options}\n     */\n    const options = Object.assign(\n      {\n        tileCoord: [z, x, y],\n        loader: loader,\n        size: size,\n        controller: controller,\n      },\n      this.tileOptions,\n    );\n\n    const tile = /** @type {TileType} */ (\n      /** @type {*} */ (new DataTile(options))\n    );\n    tile.key = this.getKey();\n    tile.addEventListener(EventType.CHANGE, this.handleTileChange_);\n\n    this.tileCache.set(tileCoordKey, tile);\n    return tile;\n  }\n\n  /**\n   * Handle tile change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   */\n  handleTileChange_(event) {\n    const tile = /** @type {import(\"../Tile.js\").default} */ (event.target);\n    const uid = getUid(tile);\n    const tileState = tile.getState();\n    let type;\n    if (tileState == TileState.LOADING) {\n      this.tileLoadingKeys_[uid] = true;\n      type = TileEventType.TILELOADSTART;\n    } else if (uid in this.tileLoadingKeys_) {\n      delete this.tileLoadingKeys_[uid];\n      type =\n        tileState == TileState.ERROR\n          ? TileEventType.TILELOADERROR\n          : tileState == TileState.LOADED\n            ? TileEventType.TILELOADEND\n            : undefined;\n    }\n    if (type) {\n      this.dispatchEvent(new TileSourceEvent(type, tile));\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {!import(\"../tilegrid/TileGrid.js\").default} Tile grid.\n   * @override\n   */\n  getTileGridForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {\n      return this.tileGrid;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileGridForProjection_)) {\n      this.tileGridForProjection_[projKey] =\n        getTileGridForProjection(projection);\n    }\n    return this.tileGridForProjection_[projKey];\n  }\n\n  /**\n   * Sets the tile grid to use when reprojecting the tiles to the given\n   * projection instead of the default tile grid for the projection.\n   *\n   * This can be useful when the default tile grid cannot be created\n   * (e.g. projection has no extent defined) or\n   * for optimization reasons (custom tile size, resolutions, ...).\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tilegrid Tile grid to use for the projection.\n   * @api\n   */\n  setTileGridForProjection(projection, tilegrid) {\n    const proj = getProjection(projection);\n    if (proj) {\n      const projKey = getUid(proj);\n      if (!(projKey in this.tileGridForProjection_)) {\n        this.tileGridForProjection_[projKey] = tilegrid;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../TileCache.js\").default} Tile cache.\n   * @override\n   */\n  getTileCacheForProjection(projection) {\n    const thisProj = this.getProjection();\n    if (!thisProj || equivalent(thisProj, projection)) {\n      return this.tileCache;\n    }\n\n    const projKey = getUid(projection);\n    if (!(projKey in this.tileCacheForProjection_)) {\n      this.tileCacheForProjection_[projKey] = new TileCache(0.1); // don't cache\n    }\n    return this.tileCacheForProjection_[projKey];\n  }\n\n  /**\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {!Object<string, boolean>} usedTiles Used tiles.\n   * @override\n   */\n  expireCache(projection, usedTiles) {\n    const usedTileCache = this.getTileCacheForProjection(projection);\n\n    this.tileCache.expireCache(\n      this.tileCache == usedTileCache ? usedTiles : {},\n    );\n    for (const id in this.tileCacheForProjection_) {\n      const tileCache = this.tileCacheForProjection_[id];\n      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});\n    }\n  }\n\n  /**\n   * @override\n   */\n  clear() {\n    super.clear();\n    for (const id in this.tileCacheForProjection_) {\n      this.tileCacheForProjection_[id].clear();\n    }\n  }\n}\n\nexport default DataTileSource;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,cAAc,MAAM,uBAAuB;AAClD,OAAOC,SAAS,MAAM,iBAAiB;AACvC,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,OAAOC,UAAU,IAAGC,eAAe,QAAO,WAAW;AACrD,OAAOC,SAAS,MAAM,iBAAiB;AACvC,SACEC,SAAS,EACTC,oBAAoB,EACpBC,gBAAgB,IAAIC,wBAAwB,QACvC,gBAAgB;AACvB,SAAQC,UAAU,EAAEC,GAAG,IAAIC,aAAa,QAAO,YAAY;AAC3D,SAAQC,SAAS,QAAO,iBAAiB;AACzC,SAAQC,MAAM,QAAO,YAAY;AACjC,SAAQC,SAAS,QAAO,iBAAiB;AACzC,SAAQC,MAAM,QAAO,YAAY;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,SAASd,UAAU,CAAC;EACtC;AACF;AACA;EACEe,WAAWA,CAACC,OAAO,EAAE;IACnB,MAAMC,UAAU,GACdD,OAAO,CAACC,UAAU,KAAKC,SAAS,GAAG,WAAW,GAAGF,OAAO,CAACC,UAAU;IAErE,IAAIE,QAAQ,GAAGH,OAAO,CAACG,QAAQ;IAC/B,IAAIA,QAAQ,KAAKD,SAAS,IAAID,UAAU,EAAE;MACxCE,QAAQ,GAAGhB,SAAS,CAAC;QACnBiB,MAAM,EAAEhB,oBAAoB,CAACa,UAAU,CAAC;QACxCI,aAAa,EAAEL,OAAO,CAACK,aAAa;QACpCC,OAAO,EAAEN,OAAO,CAACM,OAAO;QACxBC,OAAO,EAAEP,OAAO,CAACO,OAAO;QACxBC,QAAQ,EAAER,OAAO,CAACQ;MACpB,CAAC,CAAC;IACJ;IAEA,KAAK,CAAC;MACJC,SAAS,EAAE,GAAG;MAAE;MAChBC,YAAY,EAAEV,OAAO,CAACU,YAAY;MAClCC,uBAAuB,EAAEX,OAAO,CAACW,uBAAuB;MACxDV,UAAU,EAAEA,UAAU;MACtBE,QAAQ,EAAEA,QAAQ;MAClBS,KAAK,EAAEZ,OAAO,CAACY,KAAK;MACpBC,KAAK,EAAEb,OAAO,CAACa,KAAK;MACpBC,UAAU,EAAEd,OAAO,CAACc,UAAU;MAC9BC,WAAW,EAAEf,OAAO,CAACe,WAAW;MAChCC,GAAG,EAAEhB,OAAO,CAACgB;IACf,CAAC,CAAC;;IAEF;AACJ;AACA;AACA;IACI,IAAI,CAACC,OAAO,GAAGjB,OAAO,CAACkB,MAAM,KAAKhB,SAAS,GAAGF,OAAO,CAACkB,MAAM,GAAG,CAAC;;IAEhE;AACJ;AACA;AACA;IACI,IAAI,CAACC,SAAS,GAAGnB,OAAO,CAACQ,QAAQ,GAAGX,MAAM,CAACG,OAAO,CAACQ,QAAQ,CAAC,GAAG,IAAI;;IAEnE;AACJ;AACA;AACA;IACI,IAAI,CAACY,UAAU,GAAG,IAAI;;IAEtB;AACJ;AACA;AACA;IACI,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAAC;;IAE1B;AACJ;AACA;IACI,IAAI,CAACC,OAAO,GAAGtB,OAAO,CAACuB,MAAM;;IAE7B;AACJ;AACA;IACI,IAAI,CAACC,iBAAiB,GAAG,IAAI,CAACA,iBAAiB,CAACC,IAAI,CAAC,IAAI,CAAC;;IAE1D;AACJ;AACA;IACI,IAAI,CAACC,SAAS,GAAG1B,OAAO,CAAC0B,SAAS,KAAKxB,SAAS,GAAG,CAAC,GAAGF,OAAO,CAAC0B,SAAS,CAAC,CAAC;;IAE1E;AACJ;AACA;AACA;IACI,IAAI,CAACC,sBAAsB,GAAG,CAAC,CAAC;;IAEhC;AACJ;AACA;AACA;IACI,IAAI,CAACC,uBAAuB,GAAG,CAAC,CAAC;;IAEjC;AACJ;AACA;AACA;IACI,IAAI,CAACC,YAAY,GAAG7B,OAAO,CAAC8B,WAAW,IAAI,WAAW;EACxD;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,YAAYA,CAACC,SAAS,EAAE;IACtB,IAAI,CAACZ,UAAU,GAAGY,SAAS;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,CAAC,EAAE;IACb,IAAI,IAAI,CAACd,UAAU,EAAE;MACnB,OAAO,IAAI,CAACA,UAAU,CAACc,CAAC,CAAC;IAC3B;IACA,IAAI,IAAI,CAACf,SAAS,EAAE;MAClB,OAAO,IAAI,CAACA,SAAS;IACvB;IACA,MAAMhB,QAAQ,GAAG,IAAI,CAACgC,WAAW,CAAC,CAAC;IACnC,OAAOhC,QAAQ,GAAGN,MAAM,CAACM,QAAQ,CAAC8B,WAAW,CAACC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;EACEE,sBAAsBA,CAACnC,UAAU,EAAE;IACjC,MAAMoC,QAAQ,GAAG,IAAI,CAAC5C,aAAa,CAAC,CAAC;IACrC,IAAI,CAAC4C,QAAQ,IAAI9C,UAAU,CAAC8C,QAAQ,EAAEpC,UAAU,CAAC,EAAE;MACjD,OAAO,IAAI,CAACgB,OAAO;IACrB;IAEA,OAAO,CAAC;EACV;;EAEA;AACF;AACA;AACA;EACEqB,SAASA,CAACf,MAAM,EAAE;IAChB,IAAI,CAACD,OAAO,GAAGC,MAAM;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEgB,cAAcA,CAACL,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAEC,UAAU,EAAEC,UAAU,EAAE;IAC9C,MAAMC,KAAK,GAAG,IAAI,CAACC,yBAAyB,CAACH,UAAU,CAAC;IACxD,MAAMI,YAAY,GAAGpD,SAAS,CAACwC,CAAC,EAAEM,CAAC,EAAEC,CAAC,CAAC;IACvC,IAAIG,KAAK,CAACG,WAAW,CAACD,YAAY,CAAC,EAAE;MACnC,MAAME,IAAI,GAAGJ,KAAK,CAACpD,GAAG,CAACsD,YAAY,CAAC;MACpC,IAAIE,IAAI,IAAIA,IAAI,CAAChC,GAAG,IAAI,IAAI,CAACiC,MAAM,CAAC,CAAC,EAAE;QACrC,OAAOD,IAAI;MACb;IACF;IAEA,MAAM7C,QAAQ,GAAG,IAAI,CAACgC,WAAW,CAAC,CAAC;IACnC,MAAMe,oBAAoB,GAAGC,IAAI,CAACC,GAAG,CAACC,KAAK,CACzC,IAAI,EACJlD,QAAQ,CAACmD,cAAc,CAAC,CAAC,CAACC,GAAG,CAAC,CAACC,CAAC,EAAEtB,CAAC,KAAK;MACtC,MAAM1B,QAAQ,GAAGX,MAAM,CAACM,QAAQ,CAAC8B,WAAW,CAACC,CAAC,CAAC,CAAC;MAChD,MAAMuB,WAAW,GAAG,IAAI,CAACxB,WAAW,CAACC,CAAC,CAAC;MACvC,OAAOiB,IAAI,CAACC,GAAG,CACbK,WAAW,CAAC,CAAC,CAAC,GAAGjD,QAAQ,CAAC,CAAC,CAAC,EAC5BiD,WAAW,CAAC,CAAC,CAAC,GAAGjD,QAAQ,CAAC,CAAC,CAC7B,CAAC;IACH,CAAC,CACH,CAAC;IAED,MAAMkD,cAAc,GAAG,IAAI,CAACpE,wBAAwB,CAACqD,UAAU,CAAC;IAChE,MAAMgB,cAAc,GAAG,IAAI,CAACrE,wBAAwB,CAACoD,UAAU,CAAC;IAChE,MAAMkB,SAAS,GAAG,CAAC1B,CAAC,EAAEM,CAAC,EAAEC,CAAC,CAAC;IAC3B,MAAMoB,gBAAgB,GAAG,IAAI,CAACC,8BAA8B,CAC1DF,SAAS,EACTlB,UACF,CAAC;IAED,MAAM1C,OAAO,GAAG+D,MAAM,CAACC,MAAM,CAC3B;MACErB,UAAU;MACVe,cAAc;MACdhB,UAAU;MACViB,cAAc;MACdC,SAAS;MACTC,gBAAgB;MAChBI,UAAU,EAAEf,oBAAoB;MAChChC,MAAM,EAAE,IAAI,CAACkB,sBAAsB,CAACO,UAAU,CAAC;MAC/CuB,eAAe,EAAEA,CAAChC,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAEwB,UAAU,KACnC,IAAI,CAACE,OAAO,CAACjC,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAEwB,UAAU,EAAEtB,UAAU;IAChD,CAAC,EACD,sDAAwD,IAAI,CAACyB,WAC/D,CAAC;IACD,MAAMC,OAAO,GAAG;IACd,gBAAkB,IAAIxF,cAAc,CAACmB,OAAO,CAC7C;IACDqE,OAAO,CAACrD,GAAG,GAAG,IAAI,CAACiC,MAAM,CAAC,CAAC;IAC3B,OAAOoB,OAAO;EAChB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEF,OAAOA,CAACjC,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAEwB,UAAU,EAAEhE,UAAU,EAAE;IACvC,MAAMqE,gBAAgB,GAAG,IAAI,CAAC7E,aAAa,CAAC,CAAC;IAC7C,IACE6E,gBAAgB,IAChBrE,UAAU,IACV,CAACV,UAAU,CAAC+E,gBAAgB,EAAErE,UAAU,CAAC,EACzC;MACA,OAAO,IAAI,CAACsC,cAAc,CAACL,CAAC,EAAEM,CAAC,EAAEC,CAAC,EAAExC,UAAU,EAAEqE,gBAAgB,CAAC;IACnE;IAEA,MAAMC,IAAI,GAAG,IAAI,CAACtC,WAAW,CAACC,CAAC,CAAC;IAChC,MAAMY,YAAY,GAAGpD,SAAS,CAACwC,CAAC,EAAEM,CAAC,EAAEC,CAAC,CAAC;IACvC,IAAI,IAAI,CAAC+B,SAAS,CAACzB,WAAW,CAACD,YAAY,CAAC,EAAE;MAC5C,OAAO,IAAI,CAAC0B,SAAS,CAAChF,GAAG,CAACsD,YAAY,CAAC;IACzC;IAEA,MAAM2B,YAAY,GAAG,IAAI,CAACnD,OAAO;IAEjC,MAAMoD,UAAU,GAAG,IAAIC,eAAe,CAAC,CAAC;;IAExC;AACJ;AACA;IACI,MAAMC,aAAa,GAAG;MACpBC,MAAM,EAAEH,UAAU,CAACG,MAAM;MACzB/C,WAAW,EAAE,IAAI,CAACD;IACpB,CAAC;IAED,MAAM+B,SAAS,GAAG,IAAI,CAACE,8BAA8B,CAAC,CAAC5B,CAAC,EAAEM,CAAC,EAAEC,CAAC,CAAC,CAAC;IAChE,IAAI,CAACmB,SAAS,EAAE;MACd,OAAO,IAAI;IACb;IAEA,MAAMkB,QAAQ,GAAGlB,SAAS,CAAC,CAAC,CAAC;IAC7B,MAAMmB,QAAQ,GAAGnB,SAAS,CAAC,CAAC,CAAC;IAC7B,MAAMoB,QAAQ,GAAGpB,SAAS,CAAC,CAAC,CAAC;IAC7B,SAASrC,MAAMA,CAAA,EAAG;MAChB,OAAO3B,SAAS,CAAC,YAAY;QAC3B,OAAO6E,YAAY,CAACK,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,EAAEJ,aAAa,CAAC;MAClE,CAAC,CAAC;IACJ;;IAEA;AACJ;AACA;IACI,MAAM5E,OAAO,GAAG+D,MAAM,CAACC,MAAM,CAC3B;MACEJ,SAAS,EAAE,CAAC1B,CAAC,EAAEM,CAAC,EAAEC,CAAC,CAAC;MACpBlB,MAAM,EAAEA,MAAM;MACdgD,IAAI,EAAEA,IAAI;MACVG,UAAU,EAAEA;IACd,CAAC,EACD,IAAI,CAACN,WACP,CAAC;IAED,MAAMpB,IAAI,GAAG;IACX,gBAAkB,IAAIrE,QAAQ,CAACqB,OAAO,CACvC;IACDgD,IAAI,CAAChC,GAAG,GAAG,IAAI,CAACiC,MAAM,CAAC,CAAC;IACxBD,IAAI,CAACiC,gBAAgB,CAACrG,SAAS,CAACsG,MAAM,EAAE,IAAI,CAAC1D,iBAAiB,CAAC;IAE/D,IAAI,CAACgD,SAAS,CAACW,GAAG,CAACrC,YAAY,EAAEE,IAAI,CAAC;IACtC,OAAOA,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACExB,iBAAiBA,CAAC4D,KAAK,EAAE;IACvB,MAAMpC,IAAI,GAAG,2CAA6CoC,KAAK,CAACC,MAAO;IACvE,MAAMC,GAAG,GAAG3F,MAAM,CAACqD,IAAI,CAAC;IACxB,MAAMuC,SAAS,GAAGvC,IAAI,CAACwC,QAAQ,CAAC,CAAC;IACjC,IAAIC,IAAI;IACR,IAAIF,SAAS,IAAIrG,SAAS,CAACwG,OAAO,EAAE;MAClC,IAAI,CAACrE,gBAAgB,CAACiE,GAAG,CAAC,GAAG,IAAI;MACjCG,IAAI,GAAG1G,aAAa,CAAC4G,aAAa;IACpC,CAAC,MAAM,IAAIL,GAAG,IAAI,IAAI,CAACjE,gBAAgB,EAAE;MACvC,OAAO,IAAI,CAACA,gBAAgB,CAACiE,GAAG,CAAC;MACjCG,IAAI,GACFF,SAAS,IAAIrG,SAAS,CAAC0G,KAAK,GACxB7G,aAAa,CAAC8G,aAAa,GAC3BN,SAAS,IAAIrG,SAAS,CAAC4G,MAAM,GAC3B/G,aAAa,CAACgH,WAAW,GACzB7F,SAAS;IACnB;IACA,IAAIuF,IAAI,EAAE;MACR,IAAI,CAACO,aAAa,CAAC,IAAI/G,eAAe,CAACwG,IAAI,EAAEzC,IAAI,CAAC,CAAC;IACrD;EACF;;EAEA;AACF;AACA;AACA;AACA;EACE1D,wBAAwBA,CAACW,UAAU,EAAE;IACnC,MAAMoC,QAAQ,GAAG,IAAI,CAAC5C,aAAa,CAAC,CAAC;IACrC,IAAI,IAAI,CAACU,QAAQ,KAAK,CAACkC,QAAQ,IAAI9C,UAAU,CAAC8C,QAAQ,EAAEpC,UAAU,CAAC,CAAC,EAAE;MACpE,OAAO,IAAI,CAACE,QAAQ;IACtB;IAEA,MAAM8F,OAAO,GAAGtG,MAAM,CAACM,UAAU,CAAC;IAClC,IAAI,EAAEgG,OAAO,IAAI,IAAI,CAACtE,sBAAsB,CAAC,EAAE;MAC7C,IAAI,CAACA,sBAAsB,CAACsE,OAAO,CAAC,GAClC3G,wBAAwB,CAACW,UAAU,CAAC;IACxC;IACA,OAAO,IAAI,CAAC0B,sBAAsB,CAACsE,OAAO,CAAC;EAC7C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,wBAAwBA,CAACjG,UAAU,EAAEkG,QAAQ,EAAE;IAC7C,MAAMC,IAAI,GAAG3G,aAAa,CAACQ,UAAU,CAAC;IACtC,IAAImG,IAAI,EAAE;MACR,MAAMH,OAAO,GAAGtG,MAAM,CAACyG,IAAI,CAAC;MAC5B,IAAI,EAAEH,OAAO,IAAI,IAAI,CAACtE,sBAAsB,CAAC,EAAE;QAC7C,IAAI,CAACA,sBAAsB,CAACsE,OAAO,CAAC,GAAGE,QAAQ;MACjD;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEtD,yBAAyBA,CAAC5C,UAAU,EAAE;IACpC,MAAMoC,QAAQ,GAAG,IAAI,CAAC5C,aAAa,CAAC,CAAC;IACrC,IAAI,CAAC4C,QAAQ,IAAI9C,UAAU,CAAC8C,QAAQ,EAAEpC,UAAU,CAAC,EAAE;MACjD,OAAO,IAAI,CAACuE,SAAS;IACvB;IAEA,MAAMyB,OAAO,GAAGtG,MAAM,CAACM,UAAU,CAAC;IAClC,IAAI,EAAEgG,OAAO,IAAI,IAAI,CAACrE,uBAAuB,CAAC,EAAE;MAC9C,IAAI,CAACA,uBAAuB,CAACqE,OAAO,CAAC,GAAG,IAAInH,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;IAC9D;IACA,OAAO,IAAI,CAAC8C,uBAAuB,CAACqE,OAAO,CAAC;EAC9C;;EAEA;AACF;AACA;AACA;AACA;EACEI,WAAWA,CAACpG,UAAU,EAAEqG,SAAS,EAAE;IACjC,MAAMC,aAAa,GAAG,IAAI,CAAC1D,yBAAyB,CAAC5C,UAAU,CAAC;IAEhE,IAAI,CAACuE,SAAS,CAAC6B,WAAW,CACxB,IAAI,CAAC7B,SAAS,IAAI+B,aAAa,GAAGD,SAAS,GAAG,CAAC,CACjD,CAAC;IACD,KAAK,MAAME,EAAE,IAAI,IAAI,CAAC5E,uBAAuB,EAAE;MAC7C,MAAM4C,SAAS,GAAG,IAAI,CAAC5C,uBAAuB,CAAC4E,EAAE,CAAC;MAClDhC,SAAS,CAAC6B,WAAW,CAAC7B,SAAS,IAAI+B,aAAa,GAAGD,SAAS,GAAG,CAAC,CAAC,CAAC;IACpE;EACF;;EAEA;AACF;AACA;EACEG,KAAKA,CAAA,EAAG;IACN,KAAK,CAACA,KAAK,CAAC,CAAC;IACb,KAAK,MAAMD,EAAE,IAAI,IAAI,CAAC5E,uBAAuB,EAAE;MAC7C,IAAI,CAACA,uBAAuB,CAAC4E,EAAE,CAAC,CAACC,KAAK,CAAC,CAAC;IAC1C;EACF;AACF;AAEA,eAAe3G,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}