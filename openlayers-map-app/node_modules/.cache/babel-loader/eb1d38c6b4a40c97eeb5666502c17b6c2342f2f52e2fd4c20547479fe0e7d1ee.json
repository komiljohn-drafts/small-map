{"ast":null,"code":"/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport { abstract, getUid } from '../../util.js';\nimport { create as createMat4 } from '../../vec/mat4.js';\nimport { createOrUpdate as createTileCoord, getKey as getTileCoordKey } from '../../tilecoord.js';\nimport { create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { descending } from '../../array.js';\nimport { fromUserExtent } from '../../proj.js';\nimport { getIntersection, isEmpty } from '../../extent.js';\nimport { toSize } from '../../size.js';\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent',\n  // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix'\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {\n    tileIds: new Set(),\n    representationsByZ: {}\n  };\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(extent, fromUserExtent(layerState.extent, frameState.viewState.projection));\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */\n  layerState.layer.getRenderSource();\n  if (!source.getWrapX()) {\n    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @override\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms\n    });\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tileRepresentationLookup, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(initialZ - preload, tileGrid.getMinZoom(), tileGrid.getZForResolution(Math.min(tileLayer.getMaxResolution(), map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)), tileSource.zDirection));\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, this.tempTileRange_);\n      const tileResolution = tileGrid.getResolution(z);\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (!tileRepresentation || tileRepresentation.tile.key !== tileSource.getKey()) {\n            tile = tileSource.getTile(z, x, y, frameState.pixelRatio, viewState.projection);\n            if (!tile) {\n              continue;\n            }\n          }\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            tileRepresentation.setTile(tile);\n          }\n          addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, z);\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tileCoord), tileResolution]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(tileRepresentation, tileTransform, frameState, renderExtent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n  drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n    const tileScale = viewState.resolution / tileResolution;\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n    resetTransform(this.tileTransform_);\n    scaleTransform(this.tileTransform_, 2 / (frameState.size[0] * tileScale / tileWidthWithGutter), -2 / (frameState.size[1] * tileScale / tileWidthWithGutter));\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(this.tileTransform_, (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter, (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter);\n    this.renderTile(/** @type {TileRepresentation} */tileRepresentation, this.tileTransform_, frameState, extent, tileResolution, tileSize, tileOrigin, tileExtent, depth, gutter, alpha);\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(viewState.nextResolution, tileSource.zDirection);\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tileRepresentationLookup, preload);\n    }\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(frameState, extent, z - 1, tileRepresentationLookup, preload - 1);\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n\n    // look for cached tiles to use if a target tile is not ready\n    if (z in representationsByZ) {\n      for (const tileRepresentation of representationsByZ[z]) {\n        const tile = tileRepresentation.tile;\n        if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tile.getState() === TileState.EMPTY) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n        if (tileRepresentation.ready) {\n          const alpha = tile.getAlpha(uid, time);\n          if (alpha === 1) {\n            // no need to look for alt tiles\n            tile.endTransition(uid);\n            continue;\n          }\n          blend = true;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          alphaLookup[tileCoordKey] = alpha;\n        }\n        this.renderComplete = false;\n\n        // first look for child tiles (at z + 1)\n        const coveredByChildren = this.findAltTiles_(tileGrid, tileCoord, z + 1, tileRepresentationLookup);\n        if (coveredByChildren) {\n          continue;\n        }\n\n        // next look for parent tiles\n        const minZoom = tileGrid.getMinZoom();\n        for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n          const coveredByParent = this.findAltTiles_(tileGrid, tileCoord, parentZ, tileRepresentationLookup);\n          if (coveredByParent) {\n            break;\n          }\n        }\n      }\n    }\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask(/** @type {TileRepresentation} */tileRepresentation, tileZ, tileExtent, depthForZ(tileZ));\n        }\n      }\n    }\n    this.beforeTilesRender(frameState, blend);\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n        this.drawTile_(frameState, tileRepresentation, tileZ, gutter, extent, alphaLookup, tileGrid);\n      }\n    }\n    if (z in representationsByZ) {\n      for (const tileRepresentation of representationsByZ[z]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          this.drawTile_(frameState, tileRepresentation, z, gutter, extent, alphaLookup, tileGrid);\n        }\n      }\n    }\n    this.helper.finalizeDraw(frameState, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);\n    const canvas = this.helper.getCanvas();\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n    frameState.postRenderFunctions.push(postRenderFunction);\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(tileCoord, altZ, this.tempTileRange_);\n    if (!tileRange) {\n      return false;\n    }\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (tileRepresentation.ready && !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)) {\n            addTileRepresentationToLookup(tileRepresentationLookup, tileRepresentation, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @override\n   */\n  clearCache() {\n    super.clearCache();\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach(tileRepresentation => tileRepresentation.dispose());\n    tileRepresentationCache.clear();\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    super.afterHelperCreated();\n    this.tileRepresentationCache.forEach(tileRepresentation => tileRepresentation.setHelper(this.helper));\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\nexport default WebGLBaseTileLayerRenderer;","map":{"version":3,"names":["LRUCache","ReprojDataTile","ReprojTile","TileRange","TileState","WebGLLayerRenderer","abstract","getUid","create","createMat4","createOrUpdate","createTileCoord","getKey","getTileCoordKey","createTransform","reset","resetTransform","rotate","rotateTransform","scale","scaleTransform","translate","translateTransform","descending","fromUserExtent","getIntersection","isEmpty","toSize","Uniforms","TILE_TRANSFORM","TRANSITION_ALPHA","DEPTH","RENDER_EXTENT","PATTERN_ORIGIN","RESOLUTION","ZOOM","GLOBAL_ALPHA","PROJECTION_MATRIX","SCREEN_TO_WORLD_MATRIX","empty","depthForZ","z","newTileRepresentationLookup","tileIds","Set","representationsByZ","lookupHasTile","tileRepresentationLookup","tile","has","addTileRepresentationToLookup","tileRepresentation","add","getRenderExtent","frameState","extent","layerState","layerStatesArray","layerIndex","viewState","projection","source","layer","getRenderSource","getWrapX","gridExtent","getTileGridForProjection","getExtent","getCacheKey","tileCoord","WebGLBaseTileLayerRenderer","constructor","tileLayer","options","uniforms","postProcesses","renderComplete","tileTransform_","tempMat4","tempTileRange_","tempTileCoord_","tempSize_","cacheSize","undefined","tileRepresentationCache","projection_","prepareFrameInternal","clearCache","getLayer","getState","createTileRepresentation","enqueueTiles","initialZ","preload","tileSource","tileGrid","gutter","getGutterForProjection","tileSourceKey","wantedTiles","map","getMapInternal","minZ","Math","max","getMinZoom","getZForResolution","min","getMaxResolution","getView","getResolutionForZoom","getResolution","zDirection","tileRange","getTileRangeForExtentAndZ","tileResolution","x","minX","maxX","y","minY","maxY","cacheKey","containsKey","get","key","getTile","pixelRatio","grid","helper","set","setTile","tileQueueKey","IDLE","tileQueue","isKeyQueued","enqueue","getTileCoordCenter","beforeTilesRender","tilesWithAlpha","prepareDraw","beforeTilesMaskRender","renderTile","tileTransform","renderExtent","tileSize","tileOrigin","tileExtent","depth","alpha","renderTileMask","tileZ","drawTile_","alphaLookup","ready","tileCoordKey","getTileSize","getOrigin","getTileCoordExtent","animate","centerX","center","centerY","tileWidthWithGutter","tileHeightWithGutter","aspectRatio","centerI","centerJ","tileScale","resolution","tileCenterI","tileCenterJ","size","rotation","renderFrame","gl","getGL","preRender","getPreload","nextExtent","targetZ","nextResolution","setTimeout","uid","time","blend","EMPTY","getAlpha","endTransition","coveredByChildren","findAltTiles_","minZoom","parentZ","coveredByParent","zs","Object","keys","Number","sort","j","jj","length","finalizeDraw","dispatchPreComposeEvent","dispatchPostComposeEvent","canvas","getCanvas","canExpireCache","pop","dispose","postRenderFunction","expireCache","postRenderFunctions","push","postRender","altZ","getTileRangeForTileCoordAndZ","covered","loaded","forEach","clear","afterHelperCreated","setHelper","disposeInternal"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/renderer/webgl/TileLayerBase.js"],"sourcesContent":["/**\n * @module ol/renderer/webgl/TileLayerBase\n */\nimport LRUCache from '../../structs/LRUCache.js';\nimport ReprojDataTile from '../../reproj/DataTile.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {abstract, getUid} from '../../util.js';\nimport {create as createMat4} from '../../vec/mat4.js';\nimport {\n  createOrUpdate as createTileCoord,\n  getKey as getTileCoordKey,\n} from '../../tilecoord.js';\nimport {\n  create as createTransform,\n  reset as resetTransform,\n  rotate as rotateTransform,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {descending} from '../../array.js';\nimport {fromUserExtent} from '../../proj.js';\nimport {getIntersection, isEmpty} from '../../extent.js';\nimport {toSize} from '../../size.js';\n\nexport const Uniforms = {\n  TILE_TRANSFORM: 'u_tileTransform',\n  TRANSITION_ALPHA: 'u_transitionAlpha',\n  DEPTH: 'u_depth',\n  RENDER_EXTENT: 'u_renderExtent', // intersection of layer, source, and view extent\n  PATTERN_ORIGIN: 'u_patternOrigin',\n  RESOLUTION: 'u_resolution',\n  ZOOM: 'u_zoom',\n  GLOBAL_ALPHA: 'u_globalAlpha',\n  PROJECTION_MATRIX: 'u_projectionMatrix',\n  SCREEN_TO_WORLD_MATRIX: 'u_screenToWorldMatrix',\n};\n\n/**\n * @type {Object<string, boolean>}\n */\nconst empty = {};\n\n/**\n * Transform a zoom level into a depth value; zoom level zero has a depth value of 0.5, and increasing values\n * have a depth trending towards 0\n * @param {number} z A zoom level.\n * @return {number} A depth value.\n */\nfunction depthForZ(z) {\n  return 1 / (z + 2);\n}\n\n/**\n * @typedef {import(\"../../webgl/BaseTileRepresentation.js\").default<import(\"../../Tile.js\").default>} AbstractTileRepresentation\n */\n/**\n * @typedef {Object} TileRepresentationLookup\n * @property {Set<string>} tileIds The set of tile ids in the lookup.\n * @property {Object<number, Set<AbstractTileRepresentation>>} representationsByZ Tile representations by zoom level.\n */\n\n/**\n * @return {TileRepresentationLookup} A new tile representation lookup.\n */\nexport function newTileRepresentationLookup() {\n  return {tileIds: new Set(), representationsByZ: {}};\n}\n\n/**\n * Check if a tile is already in the tile representation lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @return {boolean} The tile is already in the lookup.\n */\nfunction lookupHasTile(tileRepresentationLookup, tile) {\n  return tileRepresentationLookup.tileIds.has(getUid(tile));\n}\n\n/**\n * Add a tile representation to the lookup.\n * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of tile representations by zoom level.\n * @param {AbstractTileRepresentation} tileRepresentation A tile representation.\n * @param {number} z The zoom level.\n */\nfunction addTileRepresentationToLookup(\n  tileRepresentationLookup,\n  tileRepresentation,\n  z,\n) {\n  const representationsByZ = tileRepresentationLookup.representationsByZ;\n  if (!(z in representationsByZ)) {\n    representationsByZ[z] = new Set();\n  }\n  representationsByZ[z].add(tileRepresentation);\n  tileRepresentationLookup.tileIds.add(getUid(tileRepresentation.tile));\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\nexport function getCacheKey(source, tileCoord) {\n  return `${source.getKey()},${getTileCoordKey(tileCoord)}`;\n}\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, import(\"../../webgl/Helper\").UniformValue>} [uniforms] Additional uniforms\n * made available to shaders.\n * @property {number} [cacheSize=512] The tile representation cache size.\n * @property {Array<import('./Layer.js').PostProcessesOptions>} [postProcesses] Post-processes definitions.\n */\n\n/**\n * @typedef {import(\"../../layer/BaseTile.js\").default} BaseLayerType\n */\n\n/**\n * @classdesc\n * Base WebGL renderer for tile layers.\n * @template {BaseLayerType} LayerType\n * @template {import(\"../../Tile.js\").default} TileType\n * @template {import(\"../../webgl/BaseTileRepresentation.js\").default<TileType>} TileRepresentation\n * @extends {WebGLLayerRenderer<LayerType>}\n */\nclass WebGLBaseTileLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} options Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer, {\n      uniforms: options.uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * This transform converts representation coordinates to screen coordinates.\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.tileTransform_ = createTransform();\n\n    /**\n     * @type {Array<number>}\n     * @protected\n     */\n    this.tempMat4 = createMat4();\n\n    /**\n     * @type {import(\"../../TileRange.js\").default}\n     * @private\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    /**\n     * @type {import(\"../../size.js\").Size}\n     * @private\n     */\n    this.tempSize_ = [0, 0];\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<TileRepresentation>}\n     * @protected\n     */\n    this.tileRepresentationCache = new LRUCache(cacheSize);\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection.js\").default}\n     */\n    this.projection_ = undefined;\n  }\n\n  /**\n   * @param {Options} options Options.\n   * @override\n   */\n  reset(options) {\n    super.reset({\n      uniforms: options.uniforms,\n    });\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrameInternal(frameState) {\n    if (!this.projection_) {\n      this.projection_ = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.projection_) {\n      this.clearCache();\n      this.projection_ = frameState.viewState.projection;\n    }\n\n    const layer = this.getLayer();\n    const source = layer.getRenderSource();\n    if (!source) {\n      return false;\n    }\n\n    if (isEmpty(getRenderExtent(frameState, frameState.extent))) {\n      return false;\n    }\n    return source.getState() === 'ready';\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../../webgl/BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options tile representation options\n   * @return {TileRepresentation} A new tile representation\n   * @protected\n   */\n  createTileRepresentation(options) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup The zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(\n    frameState,\n    extent,\n    initialZ,\n    tileRepresentationLookup,\n    preload,\n  ) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n    const tileRepresentationCache = this.tileRepresentationCache;\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n          const cacheKey = getCacheKey(tileSource, tileCoord);\n\n          /** @type {TileRepresentation} */\n          let tileRepresentation;\n\n          /** @type {TileType} */\n          let tile;\n\n          if (tileRepresentationCache.containsKey(cacheKey)) {\n            tileRepresentation = tileRepresentationCache.get(cacheKey);\n            tile = tileRepresentation.tile;\n          }\n          if (\n            !tileRepresentation ||\n            tileRepresentation.tile.key !== tileSource.getKey()\n          ) {\n            tile = tileSource.getTile(\n              z,\n              x,\n              y,\n              frameState.pixelRatio,\n              viewState.projection,\n            );\n            if (!tile) {\n              continue;\n            }\n          }\n\n          if (lookupHasTile(tileRepresentationLookup, tile)) {\n            continue;\n          }\n\n          if (!tileRepresentation) {\n            tileRepresentation = this.createTileRepresentation({\n              tile: tile,\n              grid: tileGrid,\n              helper: this.helper,\n              gutter: gutter,\n            });\n            tileRepresentationCache.set(cacheKey, tileRepresentation);\n          } else {\n            tileRepresentation.setTile(tile);\n          }\n\n          addTileRepresentationToLookup(\n            tileRepresentationLookup,\n            tileRepresentation,\n            z,\n          );\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} tilesWithAlpha True if at least one of the rendered tiles has alpha\n   * @protected\n   */\n  beforeTilesRender(frameState, tilesWithAlpha) {\n    this.helper.prepareDraw(this.frameState, !tilesWithAlpha, true);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} If returns false, tile mask rendering will be skipped\n   * @protected\n   */\n  beforeTilesMaskRender(frameState) {\n    return false;\n  }\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {import(\"../../transform.js\").Transform} tileTransform Tile transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state\n   * @param {import(\"../../extent.js\").Extent} renderExtent Render extent\n   * @param {number} tileResolution Tile resolution\n   * @param {import(\"../../size.js\").Size} tileSize Tile size\n   * @param {import(\"../../coordinate.js\").Coordinate} tileOrigin Tile origin\n   * @param {import(\"../../extent.js\").Extent} tileExtent tile Extent\n   * @param {number} depth Depth\n   * @param {number} gutter Gutter\n   * @param {number} alpha Alpha\n   * @protected\n   */\n  renderTile(\n    tileRepresentation,\n    tileTransform,\n    frameState,\n    renderExtent,\n    tileResolution,\n    tileSize,\n    tileOrigin,\n    tileExtent,\n    depth,\n    gutter,\n    alpha,\n  ) {}\n\n  /**\n   * @param {TileRepresentation} tileRepresentation Tile representation\n   * @param {number} tileZ Tile Z\n   * @param {import(\"../../extent.js\").Extent} extent Render extent\n   * @param {number} depth Depth\n   * @protected\n   */\n  renderTileMask(tileRepresentation, tileZ, extent, depth) {}\n\n  drawTile_(\n    frameState,\n    tileRepresentation,\n    tileZ,\n    gutter,\n    extent,\n    alphaLookup,\n    tileGrid,\n  ) {\n    if (!tileRepresentation.ready) {\n      return;\n    }\n    const tile = tileRepresentation.tile;\n    const tileCoord = tile.tileCoord;\n    const tileCoordKey = getTileCoordKey(tileCoord);\n    const alpha = tileCoordKey in alphaLookup ? alphaLookup[tileCoordKey] : 1;\n\n    const tileResolution = tileGrid.getResolution(tileZ);\n    const tileSize = toSize(tileGrid.getTileSize(tileZ), this.tempSize_);\n    const tileOrigin = tileGrid.getOrigin(tileZ);\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n    // tiles with alpha are rendered last to allow blending\n    const depth = alpha < 1 ? -1 : depthForZ(tileZ);\n    if (alpha < 1) {\n      frameState.animate = true;\n    }\n\n    const viewState = frameState.viewState;\n    const centerX = viewState.center[0];\n    const centerY = viewState.center[1];\n\n    const tileWidthWithGutter = tileSize[0] + 2 * gutter;\n    const tileHeightWithGutter = tileSize[1] + 2 * gutter;\n\n    const aspectRatio = tileWidthWithGutter / tileHeightWithGutter;\n\n    const centerI = (centerX - tileOrigin[0]) / (tileSize[0] * tileResolution);\n    const centerJ = (tileOrigin[1] - centerY) / (tileSize[1] * tileResolution);\n\n    const tileScale = viewState.resolution / tileResolution;\n\n    const tileCenterI = tileCoord[1];\n    const tileCenterJ = tileCoord[2];\n\n    resetTransform(this.tileTransform_);\n    scaleTransform(\n      this.tileTransform_,\n      2 / ((frameState.size[0] * tileScale) / tileWidthWithGutter),\n      -2 / ((frameState.size[1] * tileScale) / tileWidthWithGutter),\n    );\n    rotateTransform(this.tileTransform_, viewState.rotation);\n    scaleTransform(this.tileTransform_, 1, 1 / aspectRatio);\n    translateTransform(\n      this.tileTransform_,\n      (tileSize[0] * (tileCenterI - centerI) - gutter) / tileWidthWithGutter,\n      (tileSize[1] * (tileCenterJ - centerJ) - gutter) / tileHeightWithGutter,\n    );\n\n    this.renderTile(\n      /** @type {TileRepresentation} */ (tileRepresentation),\n      this.tileTransform_,\n      frameState,\n      extent,\n      tileResolution,\n      tileSize,\n      tileOrigin,\n      tileExtent,\n      depth,\n      gutter,\n      alpha,\n    );\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState) {\n    this.frameState = frameState;\n    this.renderComplete = true;\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const gutter = tileSource.getGutterForProjection(viewState.projection);\n    const extent = getRenderExtent(frameState, frameState.extent);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    /**\n     * @type {TileRepresentationLookup}\n     */\n    const tileRepresentationLookup = newTileRepresentationLookup();\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(\n        frameState,\n        nextExtent,\n        targetZ,\n        tileRepresentationLookup,\n        preload,\n      );\n    }\n\n    this.enqueueTiles(frameState, extent, z, tileRepresentationLookup, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          extent,\n          z - 1,\n          tileRepresentationLookup,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    /**\n     * A lookup of alpha values for tiles at the target rendering resolution\n     * for tiles that are in transition.  If a tile coord key is absent from\n     * this lookup, the tile should be rendered at alpha 1.\n     * @type {Object<string, number>}\n     */\n    const alphaLookup = {};\n\n    const uid = getUid(this);\n    const time = frameState.time;\n    let blend = false;\n\n    const representationsByZ = tileRepresentationLookup.representationsByZ;\n\n    // look for cached tiles to use if a target tile is not ready\n    if (z in representationsByZ) {\n      for (const tileRepresentation of representationsByZ[z]) {\n        const tile = tileRepresentation.tile;\n        if (\n          (tile instanceof ReprojTile || tile instanceof ReprojDataTile) &&\n          tile.getState() === TileState.EMPTY\n        ) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        if (tileRepresentation.ready) {\n          const alpha = tile.getAlpha(uid, time);\n          if (alpha === 1) {\n            // no need to look for alt tiles\n            tile.endTransition(uid);\n            continue;\n          }\n          blend = true;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          alphaLookup[tileCoordKey] = alpha;\n        }\n        this.renderComplete = false;\n\n        // first look for child tiles (at z + 1)\n        const coveredByChildren = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          z + 1,\n          tileRepresentationLookup,\n        );\n\n        if (coveredByChildren) {\n          continue;\n        }\n\n        // next look for parent tiles\n        const minZoom = tileGrid.getMinZoom();\n        for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n          const coveredByParent = this.findAltTiles_(\n            tileGrid,\n            tileCoord,\n            parentZ,\n            tileRepresentationLookup,\n          );\n\n          if (coveredByParent) {\n            break;\n          }\n        }\n      }\n    }\n\n    const zs = Object.keys(representationsByZ).map(Number).sort(descending);\n\n    const renderTileMask = this.beforeTilesMaskRender(frameState);\n\n    if (renderTileMask) {\n      for (let j = 0, jj = zs.length; j < jj; ++j) {\n        const tileZ = zs[j];\n        for (const tileRepresentation of representationsByZ[tileZ]) {\n          const tileCoord = tileRepresentation.tile.tileCoord;\n          const tileCoordKey = getTileCoordKey(tileCoord);\n          // do not render the tile mask if alpha < 1\n          if (tileCoordKey in alphaLookup) {\n            continue;\n          }\n          const tileExtent = tileGrid.getTileCoordExtent(tileCoord);\n          this.renderTileMask(\n            /** @type {TileRepresentation} */ (tileRepresentation),\n            tileZ,\n            tileExtent,\n            depthForZ(tileZ),\n          );\n        }\n      }\n    }\n\n    this.beforeTilesRender(frameState, blend);\n\n    for (let j = 0, jj = zs.length; j < jj; ++j) {\n      const tileZ = zs[j];\n      for (const tileRepresentation of representationsByZ[tileZ]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          continue;\n        }\n\n        this.drawTile_(\n          frameState,\n          tileRepresentation,\n          tileZ,\n          gutter,\n          extent,\n          alphaLookup,\n          tileGrid,\n        );\n      }\n    }\n\n    if (z in representationsByZ) {\n      for (const tileRepresentation of representationsByZ[z]) {\n        const tileCoord = tileRepresentation.tile.tileCoord;\n        const tileCoordKey = getTileCoordKey(tileCoord);\n        if (tileCoordKey in alphaLookup) {\n          this.drawTile_(\n            frameState,\n            tileRepresentation,\n            z,\n            gutter,\n            extent,\n            alphaLookup,\n            tileGrid,\n          );\n        }\n      }\n    }\n\n    this.helper.finalizeDraw(\n      frameState,\n      this.dispatchPreComposeEvent,\n      this.dispatchPostComposeEvent,\n    );\n\n    const canvas = this.helper.getCanvas();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    while (tileRepresentationCache.canExpireCache()) {\n      const tileRepresentation = tileRepresentationCache.pop();\n      tileRepresentation.dispose();\n    }\n\n    // TODO: let the renderers manage their own cache instead of managing the source cache\n    /**\n     * Here we unconditionally expire the source cache since the renderer maintains\n     * its own cache.\n     * @param {import(\"../../Map.js\").default} map Map.\n     * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n     */\n    const postRenderFunction = function (map, frameState) {\n      tileSource.expireCache(frameState.viewState.projection, empty);\n    };\n\n    frameState.postRenderFunctions.push(postRenderFunction);\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile representation lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileRepresentationLookup} tileRepresentationLookup Lookup of\n   * tile representations by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tileRepresentationLookup) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileRepresentationCache = this.tileRepresentationCache;\n    const source = this.getLayer().getRenderSource();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, [altZ, x, y]);\n        let loaded = false;\n        if (tileRepresentationCache.containsKey(cacheKey)) {\n          const tileRepresentation = tileRepresentationCache.get(cacheKey);\n          if (\n            tileRepresentation.ready &&\n            !lookupHasTile(tileRepresentationLookup, tileRepresentation.tile)\n          ) {\n            addTileRepresentationToLookup(\n              tileRepresentationLookup,\n              tileRepresentation,\n              altZ,\n            );\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * @override\n   */\n  clearCache() {\n    super.clearCache();\n\n    const tileRepresentationCache = this.tileRepresentationCache;\n    tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.dispose(),\n    );\n    tileRepresentationCache.clear();\n  }\n\n  /**\n   * @override\n   */\n  afterHelperCreated() {\n    super.afterHelperCreated();\n\n    this.tileRepresentationCache.forEach((tileRepresentation) =>\n      tileRepresentation.setHelper(this.helper),\n    );\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    super.disposeInternal();\n    delete this.frameState;\n  }\n}\n\nexport default WebGLBaseTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}