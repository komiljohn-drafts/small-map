{"ast":null,"code":"/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport { BooleanType, CallExpression, ColorType, NumberArrayType, NumberType, Ops, SizeType, StringType, computeGeometryType, parse, typeName } from './expression.js';\nimport { Uniforms } from '../renderer/webgl/TileLayer.js';\nimport { asArray } from '../color.js';\nimport { toSize } from '../size.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error('`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.');\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  return arrayToGlsl([array[0] / 255, array[1] / 255, array[2] / 255, alpha]);\n}\n\n/**\n * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.\n * @param {number|import('../size.js').Size} size Size.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function sizeToGlsl(size) {\n  const array = toSize(size);\n  return arrayToGlsl(array);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {}\n  };\n}\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(encoded, type, parsingContext, compilationContext) {\n  const expression = parse(encoded, type, parsingContext);\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const propName = /** @type {string} */firstArg.value;\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: feature => {\n          return computeGeometryType(feature.getGeometry());\n        }\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.LineMetric]: () => 'currentLineMetric',\n  // this variable is assumed to always be present in shaders, default is 0.\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */expression.args[0];\n    const varName = /** @type {string} */firstArg.value;\n    const isExisting = varName in context.variables;\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler(compiledArgs => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler(compiledArgs => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`),\n  [Ops.NotEqual]: createCompiler(([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`),\n  [Ops.GreaterThan]: createCompiler(([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`),\n  [Ops.LessThan]: createCompiler(([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`),\n  [Ops.LessThanOrEqualTo]: createCompiler(([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`),\n  [Ops.Multiply]: createCompiler(compiledArgs => `(${compiledArgs.join(' * ')})`),\n  [Ops.Divide]: createCompiler(([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`),\n  [Ops.Add]: createCompiler(compiledArgs => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`),\n  [Ops.Clamp]: createCompiler(([value, min, max]) => `clamp(${value}, ${min}, ${max})`),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined ? `atan(${firstValue}, ${secondValue})` : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler(compiledArgs => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler(compiledArgs => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(args => `vec${args.length}(${args.join(', ')})`),\n  [Ops.Color]: createCompiler(compiledArgs => {\n    if (compiledArgs.length === 1) {\n      //grayscale\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), 1.0)`;\n    }\n    if (compiledArgs.length === 2) {\n      //grayscale with alpha\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), ${compiledArgs[1]})`;\n    }\n    const rgb = compiledArgs.slice(0, 3).map(color => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `vec4(${rgb.join(', ')}, ${alpha})`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n      context.functions[GET_BAND_VALUE_FUNC] = `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${yOffset ?? '0.0'})`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */\n      /** @type {LiteralExpression} */colors[i].value;\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  }\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Coalesce\n  // Ops.Concat\n  // Ops.ToString\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(`No compiler defined for this operator: ${JSON.stringify(expression.operator)}`);\n    }\n    return compiler(context, expression, returnType);\n  }\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */expression.value);\n  }\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(/** @type {Array<number> | string} */expression.value);\n  }\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */expression.value);\n  }\n  if ((expression.type & SizeType) > 0) {\n    return sizeToGlsl(/** @type {number|import('../size.js').Size} */expression.value);\n  }\n  throw new Error(`Unexpected expression ${expression.value} (expected type ${typeName(returnType)})`);\n}","map":{"version":3,"names":["PaletteTexture","BooleanType","CallExpression","ColorType","NumberArrayType","NumberType","Ops","SizeType","StringType","computeGeometryType","parse","typeName","Uniforms","asArray","toSize","computeOperatorFunctionName","operator","context","Object","keys","functions","length","numberToGlsl","v","s","toString","includes","arrayToGlsl","array","Error","map","join","colorToGlsl","color","alpha","sizeToGlsl","size","stringToFloatMap","stringToFloatCounter","getStringNumberEquivalent","string","stringToGlsl","uniformNameForVariable","variableName","newCompilationContext","inFragmentShader","variables","properties","bandCount","style","GET_BAND_VALUE_FUNC","PALETTE_TEXTURE_ARRAY","buildExpression","encoded","type","parsingContext","compilationContext","expression","compile","createCompiler","output","args","Array","i","compilers","Get","firstArg","propName","value","isExisting","name","prefix","GeometryType","evaluator","feature","getGeometry","LineMetric","Var","varName","Resolution","Zoom","Time","Any","compiledArgs","All","Not","Equal","firstValue","secondValue","NotEqual","GreaterThan","GreaterThanOrEqualTo","LessThan","LessThanOrEqualTo","Multiply","Divide","Add","Subtract","Clamp","min","max","Mod","modulo","Pow","power","Abs","Floor","Ceil","Round","Sin","Cos","Atan","undefined","Sqrt","Match","input","fallback","result","match","Between","Interpolate","exponent","stop1","output1","stop2","output2","ratio","Case","condition","In","needle","haystack","funcName","tests","push","Color","rgb","slice","Band","band","xOffset","yOffset","ifBlocks","colorIndex","Math","floor","bandIndex","textureName","TILE_TEXTURE_ARRAY","TEXTURE_PIXEL_WIDTH","TEXTURE_PIXEL_HEIGHT","Palette","index","colors","numColors","palette","Uint8Array","parsedValue","offset","paletteTextures","paletteName","paletteTexture","compiledIndex","returnType","compiler","JSON","stringify"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/expr/gpu.js"],"sourcesContent":["/**\n * @module ol/expr/gpu\n */\nimport PaletteTexture from '../webgl/PaletteTexture.js';\nimport {\n  BooleanType,\n  CallExpression,\n  ColorType,\n  NumberArrayType,\n  NumberType,\n  Ops,\n  SizeType,\n  StringType,\n  computeGeometryType,\n  parse,\n  typeName,\n} from './expression.js';\nimport {Uniforms} from '../renderer/webgl/TileLayer.js';\nimport {asArray} from '../color.js';\nimport {toSize} from '../size.js';\n\n/**\n * @param {string} operator Operator\n * @param {CompilationContext} context Compilation context\n * @return {string} A function name based on the operator, unique in the given context\n */\nfunction computeOperatorFunctionName(operator, context) {\n  return `operator_${operator}_${Object.keys(context.functions).length}`;\n}\n\n/**\n * Will return the number as a float with a dot separator, which is required by GLSL.\n * @param {number} v Numerical value.\n * @return {string} The value as string.\n */\nexport function numberToGlsl(v) {\n  const s = v.toString();\n  return s.includes('.') ? s : s + '.0';\n}\n\n/**\n * Will return the number array as a float with a dot separator, concatenated with ', '.\n * @param {Array<number>} array Numerical values array.\n * @return {string} The array as a vector, e. g.: `vec3(1.0, 2.0, 3.0)`.\n */\nexport function arrayToGlsl(array) {\n  if (array.length < 2 || array.length > 4) {\n    throw new Error(\n      '`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.',\n    );\n  }\n  return `vec${array.length}(${array.map(numberToGlsl).join(', ')})`;\n}\n\n/**\n * Will normalize and converts to string a `vec4` color array compatible with GLSL.\n * @param {string|import(\"../color.js\").Color} color Color either in string format or [r, g, b, a] array format,\n * with RGB components in the 0..255 range and the alpha component in the 0..1 range.\n * Note that the final array will always have 4 components.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function colorToGlsl(color) {\n  const array = asArray(color);\n  const alpha = array.length > 3 ? array[3] : 1;\n  return arrayToGlsl([array[0] / 255, array[1] / 255, array[2] / 255, alpha]);\n}\n\n/**\n * Normalizes and converts a number or array toa `vec2` array compatible with GLSL.\n * @param {number|import('../size.js').Size} size Size.\n * @return {string} The color expressed in the `vec4(1.0, 1.0, 1.0, 1.0)` form.\n */\nexport function sizeToGlsl(size) {\n  const array = toSize(size);\n  return arrayToGlsl(array);\n}\n\n/** @type {Object<string, number>} */\nconst stringToFloatMap = {};\nlet stringToFloatCounter = 0;\n\n/**\n * Returns a stable equivalent number for the string literal.\n * @param {string} string String literal value\n * @return {number} Number equivalent\n */\nexport function getStringNumberEquivalent(string) {\n  if (!(string in stringToFloatMap)) {\n    stringToFloatMap[string] = stringToFloatCounter++;\n  }\n  return stringToFloatMap[string];\n}\n\n/**\n * Returns a stable equivalent number for the string literal, for use in shaders. This number is then\n * converted to be a GLSL-compatible string.\n * Note: with a float precision of `mediump`, the amount of unique strings supported is 16,777,216\n * @param {string} string String literal value\n * @return {string} GLSL-compatible string containing a number\n */\nexport function stringToGlsl(string) {\n  return numberToGlsl(getStringNumberEquivalent(string));\n}\n\n/**\n * Get the uniform name given a variable name.\n * @param {string} variableName The variable name.\n * @return {string} The uniform name.\n */\nexport function uniformNameForVariable(variableName) {\n  return 'u_var_' + variableName;\n}\n\n/**\n * @typedef {import('./expression.js').ParsingContext} ParsingContext\n */\n/**\n *\n * @typedef {import(\"./expression.js\").Expression} Expression\n */\n/**\n *\n * @typedef {import(\"./expression.js\").LiteralExpression} LiteralExpression\n */\n\n/**\n * @typedef {Object} CompilationContextProperty\n * @property {string} name Name\n * @property {number} type Resolved property type\n * @property {function(import(\"../Feature.js\").FeatureLike): *} [evaluator] Function used for evaluating the value;\n */\n\n/**\n * @typedef {Object} CompilationContextVariable\n * @property {string} name Name\n * @property {number} type Resolved variable type\n * @property {function(Object): *} [evaluator] Function used for evaluating the value; argument is the style variables object\n */\n\n/**\n * @typedef {Object} CompilationContext\n * @property {boolean} [inFragmentShader] If false, means the expression output should be made for a vertex shader\n * @property {Object<string, CompilationContextProperty>} properties The values for properties used in 'get' expressions.\n * @property {Object<string, CompilationContextVariable>} variables The values for variables used in 'var' expressions.\n * @property {Object<string, string>} functions Lookup of functions used by the style.\n * @property {number} [bandCount] Number of bands per pixel.\n * @property {Array<PaletteTexture>} [paletteTextures] List of palettes used by the style.\n * @property {import(\"../style/webgl.js\").WebGLStyle} style Literal style.\n */\n\n/**\n * @return {CompilationContext} A new compilation context.\n */\nexport function newCompilationContext() {\n  return {\n    inFragmentShader: false,\n    variables: {},\n    properties: {},\n    functions: {},\n    bandCount: 0,\n    style: {},\n  };\n}\n\nconst GET_BAND_VALUE_FUNC = 'getBandValue';\n\nexport const PALETTE_TEXTURE_ARRAY = 'u_paletteTextures';\n\n/**\n * @typedef {string} CompiledExpression\n */\n\n/**\n * @typedef {function(CompilationContext, CallExpression, number): string} Compiler\n * Third argument is the expected value types\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} parsingContext The parsing context.\n * @param {CompilationContext} compilationContext An existing compilation context\n * @return {CompiledExpression} The compiled expression.\n */\nexport function buildExpression(\n  encoded,\n  type,\n  parsingContext,\n  compilationContext,\n) {\n  const expression = parse(encoded, type, parsingContext);\n  return compile(expression, type, compilationContext);\n}\n\n/**\n * @param {function(Array<CompiledExpression>, CompilationContext): string} output Function that takes in parsed arguments and returns a string\n * @return {function(CompilationContext, import(\"./expression.js\").CallExpression, number): string} Compiler for the call expression\n */\nfunction createCompiler(output) {\n  return (context, expression, type) => {\n    const length = expression.args.length;\n    const args = new Array(length);\n    for (let i = 0; i < length; ++i) {\n      args[i] = compile(expression.args[i], type, context);\n    }\n    return output(args, context);\n  };\n}\n\n/**\n * @type {Object<string, Compiler>}\n */\nconst compilers = {\n  [Ops.Get]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const propName = /** @type {string} */ (firstArg.value);\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: expression.type,\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.GeometryType]: (context, expression, type) => {\n    const propName = 'geometryType';\n    const isExisting = propName in context.properties;\n    if (!isExisting) {\n      context.properties[propName] = {\n        name: propName,\n        type: StringType,\n        evaluator: (feature) => {\n          return computeGeometryType(feature.getGeometry());\n        },\n      };\n    }\n    const prefix = context.inFragmentShader ? 'v_prop_' : 'a_prop_';\n    return prefix + propName;\n  },\n  [Ops.LineMetric]: () => 'currentLineMetric', // this variable is assumed to always be present in shaders, default is 0.\n  [Ops.Var]: (context, expression) => {\n    const firstArg = /** @type {LiteralExpression} */ (expression.args[0]);\n    const varName = /** @type {string} */ (firstArg.value);\n    const isExisting = varName in context.variables;\n    if (!isExisting) {\n      context.variables[varName] = {\n        name: varName,\n        type: expression.type,\n      };\n    }\n    return uniformNameForVariable(varName);\n  },\n  [Ops.Resolution]: () => 'u_resolution',\n  [Ops.Zoom]: () => 'u_zoom',\n  [Ops.Time]: () => 'u_time',\n  [Ops.Any]: createCompiler((compiledArgs) => `(${compiledArgs.join(` || `)})`),\n  [Ops.All]: createCompiler((compiledArgs) => `(${compiledArgs.join(` && `)})`),\n  [Ops.Not]: createCompiler(([value]) => `(!${value})`),\n  [Ops.Equal]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} == ${secondValue})`,\n  ),\n  [Ops.NotEqual]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} != ${secondValue})`,\n  ),\n  [Ops.GreaterThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} > ${secondValue})`,\n  ),\n  [Ops.GreaterThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} >= ${secondValue})`,\n  ),\n  [Ops.LessThan]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} < ${secondValue})`,\n  ),\n  [Ops.LessThanOrEqualTo]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} <= ${secondValue})`,\n  ),\n  [Ops.Multiply]: createCompiler(\n    (compiledArgs) => `(${compiledArgs.join(' * ')})`,\n  ),\n  [Ops.Divide]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} / ${secondValue})`,\n  ),\n  [Ops.Add]: createCompiler((compiledArgs) => `(${compiledArgs.join(' + ')})`),\n  [Ops.Subtract]: createCompiler(\n    ([firstValue, secondValue]) => `(${firstValue} - ${secondValue})`,\n  ),\n  [Ops.Clamp]: createCompiler(\n    ([value, min, max]) => `clamp(${value}, ${min}, ${max})`,\n  ),\n  [Ops.Mod]: createCompiler(([value, modulo]) => `mod(${value}, ${modulo})`),\n  [Ops.Pow]: createCompiler(([value, power]) => `pow(${value}, ${power})`),\n  [Ops.Abs]: createCompiler(([value]) => `abs(${value})`),\n  [Ops.Floor]: createCompiler(([value]) => `floor(${value})`),\n  [Ops.Ceil]: createCompiler(([value]) => `ceil(${value})`),\n  [Ops.Round]: createCompiler(([value]) => `floor(${value} + 0.5)`),\n  [Ops.Sin]: createCompiler(([value]) => `sin(${value})`),\n  [Ops.Cos]: createCompiler(([value]) => `cos(${value})`),\n  [Ops.Atan]: createCompiler(([firstValue, secondValue]) => {\n    return secondValue !== undefined\n      ? `atan(${firstValue}, ${secondValue})`\n      : `atan(${firstValue})`;\n  }),\n  [Ops.Sqrt]: createCompiler(([value]) => `sqrt(${value})`),\n  [Ops.Match]: createCompiler((compiledArgs) => {\n    const input = compiledArgs[0];\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 1; i -= 2) {\n      const match = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${input} == ${match} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.Between]: createCompiler(\n    ([value, min, max]) => `(${value} >= ${min} && ${value} <= ${max})`,\n  ),\n  [Ops.Interpolate]: createCompiler(([exponent, input, ...compiledArgs]) => {\n    let result = '';\n    for (let i = 0; i < compiledArgs.length - 2; i += 2) {\n      const stop1 = compiledArgs[i];\n      const output1 = result || compiledArgs[i + 1];\n      const stop2 = compiledArgs[i + 2];\n      const output2 = compiledArgs[i + 3];\n      let ratio;\n      if (exponent === numberToGlsl(1)) {\n        ratio = `(${input} - ${stop1}) / (${stop2} - ${stop1})`;\n      } else {\n        ratio = `(pow(${exponent}, (${input} - ${stop1})) - 1.0) / (pow(${exponent}, (${stop2} - ${stop1})) - 1.0)`;\n      }\n      result = `mix(${output1}, ${output2}, clamp(${ratio}, 0.0, 1.0))`;\n    }\n    return result;\n  }),\n  [Ops.Case]: createCompiler((compiledArgs) => {\n    const fallback = compiledArgs[compiledArgs.length - 1];\n    let result = null;\n    for (let i = compiledArgs.length - 3; i >= 0; i -= 2) {\n      const condition = compiledArgs[i];\n      const output = compiledArgs[i + 1];\n      result = `(${condition} ? ${output} : ${result || fallback})`;\n    }\n    return result;\n  }),\n  [Ops.In]: createCompiler(([needle, ...haystack], context) => {\n    const funcName = computeOperatorFunctionName('in', context);\n    const tests = [];\n    for (let i = 0; i < haystack.length; i += 1) {\n      tests.push(`  if (inputValue == ${haystack[i]}) { return true; }`);\n    }\n    context.functions[funcName] = `bool ${funcName}(float inputValue) {\n${tests.join('\\n')}\n  return false;\n}`;\n    return `${funcName}(${needle})`;\n  }),\n  [Ops.Array]: createCompiler(\n    (args) => `vec${args.length}(${args.join(', ')})`,\n  ),\n  [Ops.Color]: createCompiler((compiledArgs) => {\n    if (compiledArgs.length === 1) {\n      //grayscale\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), 1.0)`;\n    }\n    if (compiledArgs.length === 2) {\n      //grayscale with alpha\n      return `vec4(vec3(${compiledArgs[0]} / 255.0), ${compiledArgs[1]})`;\n    }\n    const rgb = compiledArgs.slice(0, 3).map((color) => `${color} / 255.0`);\n    if (compiledArgs.length === 3) {\n      return `vec4(${rgb.join(', ')}, 1.0)`;\n    }\n    const alpha = compiledArgs[3];\n    return `vec4(${rgb.join(', ')}, ${alpha})`;\n  }),\n  [Ops.Band]: createCompiler(([band, xOffset, yOffset], context) => {\n    if (!(GET_BAND_VALUE_FUNC in context.functions)) {\n      let ifBlocks = '';\n      const bandCount = context.bandCount || 1;\n      for (let i = 0; i < bandCount; i++) {\n        const colorIndex = Math.floor(i / 4);\n        let bandIndex = i % 4;\n        if (i === bandCount - 1 && bandIndex === 1) {\n          // LUMINANCE_ALPHA - band 1 assigned to rgb and band 2 assigned to alpha\n          bandIndex = 3;\n        }\n        const textureName = `${Uniforms.TILE_TEXTURE_ARRAY}[${colorIndex}]`;\n        ifBlocks += `  if (band == ${i + 1}.0) {\n    return texture2D(${textureName}, v_textureCoord + vec2(dx, dy))[${bandIndex}];\n  }\n`;\n      }\n\n      context.functions[GET_BAND_VALUE_FUNC] =\n        `float getBandValue(float band, float xOffset, float yOffset) {\n  float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};\n  float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};\n${ifBlocks}\n}`;\n    }\n\n    return `${GET_BAND_VALUE_FUNC}(${band}, ${xOffset ?? '0.0'}, ${\n      yOffset ?? '0.0'\n    })`;\n  }),\n  [Ops.Palette]: (context, expression) => {\n    const [index, ...colors] = expression.args;\n    const numColors = colors.length;\n    const palette = new Uint8Array(numColors * 4);\n    for (let i = 0; i < colors.length; i++) {\n      const parsedValue = /** @type {string | Array<number>} */ (\n        /** @type {LiteralExpression} */ (colors[i]).value\n      );\n      const color = asArray(parsedValue);\n      const offset = i * 4;\n      palette[offset] = color[0];\n      palette[offset + 1] = color[1];\n      palette[offset + 2] = color[2];\n      palette[offset + 3] = color[3] * 255;\n    }\n    if (!context.paletteTextures) {\n      context.paletteTextures = [];\n    }\n    const paletteName = `${PALETTE_TEXTURE_ARRAY}[${context.paletteTextures.length}]`;\n    const paletteTexture = new PaletteTexture(paletteName, palette);\n    context.paletteTextures.push(paletteTexture);\n    const compiledIndex = compile(index, NumberType, context);\n    return `texture2D(${paletteName}, vec2((${compiledIndex} + 0.5) / ${numColors}.0, 0.5))`;\n  },\n  // TODO: unimplemented\n  // Ops.Number\n  // Ops.String\n  // Ops.Coalesce\n  // Ops.Concat\n  // Ops.ToString\n};\n\n/**\n * @param {Expression} expression The expression.\n * @param {number} returnType The expected return type.\n * @param {CompilationContext} context The compilation context.\n * @return {CompiledExpression} The compiled expression\n */\nfunction compile(expression, returnType, context) {\n  // operator\n  if (expression instanceof CallExpression) {\n    const compiler = compilers[expression.operator];\n    if (compiler === undefined) {\n      throw new Error(\n        `No compiler defined for this operator: ${JSON.stringify(\n          expression.operator,\n        )}`,\n      );\n    }\n    return compiler(context, expression, returnType);\n  }\n\n  if ((expression.type & NumberType) > 0) {\n    return numberToGlsl(/** @type {number} */ (expression.value));\n  }\n\n  if ((expression.type & BooleanType) > 0) {\n    return expression.value.toString();\n  }\n\n  if ((expression.type & StringType) > 0) {\n    return stringToGlsl(expression.value.toString());\n  }\n\n  if ((expression.type & ColorType) > 0) {\n    return colorToGlsl(\n      /** @type {Array<number> | string} */ (expression.value),\n    );\n  }\n\n  if ((expression.type & NumberArrayType) > 0) {\n    return arrayToGlsl(/** @type {Array<number>} */ (expression.value));\n  }\n\n  if ((expression.type & SizeType) > 0) {\n    return sizeToGlsl(\n      /** @type {number|import('../size.js').Size} */ (expression.value),\n    );\n  }\n\n  throw new Error(\n    `Unexpected expression ${expression.value} (expected type ${typeName(\n      returnType,\n    )})`,\n  );\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,cAAc,MAAM,4BAA4B;AACvD,SACEC,WAAW,EACXC,cAAc,EACdC,SAAS,EACTC,eAAe,EACfC,UAAU,EACVC,GAAG,EACHC,QAAQ,EACRC,UAAU,EACVC,mBAAmB,EACnBC,KAAK,EACLC,QAAQ,QACH,iBAAiB;AACxB,SAAQC,QAAQ,QAAO,gCAAgC;AACvD,SAAQC,OAAO,QAAO,aAAa;AACnC,SAAQC,MAAM,QAAO,YAAY;;AAEjC;AACA;AACA;AACA;AACA;AACA,SAASC,2BAA2BA,CAACC,QAAQ,EAAEC,OAAO,EAAE;EACtD,OAAO,YAAYD,QAAQ,IAAIE,MAAM,CAACC,IAAI,CAACF,OAAO,CAACG,SAAS,CAAC,CAACC,MAAM,EAAE;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACC,CAAC,EAAE;EAC9B,MAAMC,CAAC,GAAGD,CAAC,CAACE,QAAQ,CAAC,CAAC;EACtB,OAAOD,CAAC,CAACE,QAAQ,CAAC,GAAG,CAAC,GAAGF,CAAC,GAAGA,CAAC,GAAG,IAAI;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,WAAWA,CAACC,KAAK,EAAE;EACjC,IAAIA,KAAK,CAACP,MAAM,GAAG,CAAC,IAAIO,KAAK,CAACP,MAAM,GAAG,CAAC,EAAE;IACxC,MAAM,IAAIQ,KAAK,CACb,gEACF,CAAC;EACH;EACA,OAAO,MAAMD,KAAK,CAACP,MAAM,IAAIO,KAAK,CAACE,GAAG,CAACR,YAAY,CAAC,CAACS,IAAI,CAAC,IAAI,CAAC,GAAG;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,KAAK,EAAE;EACjC,MAAML,KAAK,GAAGf,OAAO,CAACoB,KAAK,CAAC;EAC5B,MAAMC,KAAK,GAAGN,KAAK,CAACP,MAAM,GAAG,CAAC,GAAGO,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC;EAC7C,OAAOD,WAAW,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,EAAEA,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,EAAEA,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG,EAAEM,KAAK,CAAC,CAAC;AAC7E;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,IAAI,EAAE;EAC/B,MAAMR,KAAK,GAAGd,MAAM,CAACsB,IAAI,CAAC;EAC1B,OAAOT,WAAW,CAACC,KAAK,CAAC;AAC3B;;AAEA;AACA,MAAMS,gBAAgB,GAAG,CAAC,CAAC;AAC3B,IAAIC,oBAAoB,GAAG,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,yBAAyBA,CAACC,MAAM,EAAE;EAChD,IAAI,EAAEA,MAAM,IAAIH,gBAAgB,CAAC,EAAE;IACjCA,gBAAgB,CAACG,MAAM,CAAC,GAAGF,oBAAoB,EAAE;EACnD;EACA,OAAOD,gBAAgB,CAACG,MAAM,CAAC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACD,MAAM,EAAE;EACnC,OAAOlB,YAAY,CAACiB,yBAAyB,CAACC,MAAM,CAAC,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,sBAAsBA,CAACC,YAAY,EAAE;EACnD,OAAO,QAAQ,GAAGA,YAAY;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,SAASC,qBAAqBA,CAAA,EAAG;EACtC,OAAO;IACLC,gBAAgB,EAAE,KAAK;IACvBC,SAAS,EAAE,CAAC,CAAC;IACbC,UAAU,EAAE,CAAC,CAAC;IACd3B,SAAS,EAAE,CAAC,CAAC;IACb4B,SAAS,EAAE,CAAC;IACZC,KAAK,EAAE,CAAC;EACV,CAAC;AACH;AAEA,MAAMC,mBAAmB,GAAG,cAAc;AAE1C,OAAO,MAAMC,qBAAqB,GAAG,mBAAmB;;AAExD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAC7BC,OAAO,EACPC,IAAI,EACJC,cAAc,EACdC,kBAAkB,EAClB;EACA,MAAMC,UAAU,GAAG/C,KAAK,CAAC2C,OAAO,EAAEC,IAAI,EAAEC,cAAc,CAAC;EACvD,OAAOG,OAAO,CAACD,UAAU,EAAEH,IAAI,EAAEE,kBAAkB,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA,SAASG,cAAcA,CAACC,MAAM,EAAE;EAC9B,OAAO,CAAC3C,OAAO,EAAEwC,UAAU,EAAEH,IAAI,KAAK;IACpC,MAAMjC,MAAM,GAAGoC,UAAU,CAACI,IAAI,CAACxC,MAAM;IACrC,MAAMwC,IAAI,GAAG,IAAIC,KAAK,CAACzC,MAAM,CAAC;IAC9B,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1C,MAAM,EAAE,EAAE0C,CAAC,EAAE;MAC/BF,IAAI,CAACE,CAAC,CAAC,GAAGL,OAAO,CAACD,UAAU,CAACI,IAAI,CAACE,CAAC,CAAC,EAAET,IAAI,EAAErC,OAAO,CAAC;IACtD;IACA,OAAO2C,MAAM,CAACC,IAAI,EAAE5C,OAAO,CAAC;EAC9B,CAAC;AACH;;AAEA;AACA;AACA;AACA,MAAM+C,SAAS,GAAG;EAChB,CAAC1D,GAAG,CAAC2D,GAAG,GAAG,CAAChD,OAAO,EAAEwC,UAAU,KAAK;IAClC,MAAMS,QAAQ,GAAG,gCAAkCT,UAAU,CAACI,IAAI,CAAC,CAAC,CAAE;IACtE,MAAMM,QAAQ,GAAG,qBAAuBD,QAAQ,CAACE,KAAM;IACvD,MAAMC,UAAU,GAAGF,QAAQ,IAAIlD,OAAO,CAAC8B,UAAU;IACjD,IAAI,CAACsB,UAAU,EAAE;MACfpD,OAAO,CAAC8B,UAAU,CAACoB,QAAQ,CAAC,GAAG;QAC7BG,IAAI,EAAEH,QAAQ;QACdb,IAAI,EAAEG,UAAU,CAACH;MACnB,CAAC;IACH;IACA,MAAMiB,MAAM,GAAGtD,OAAO,CAAC4B,gBAAgB,GAAG,SAAS,GAAG,SAAS;IAC/D,OAAO0B,MAAM,GAAGJ,QAAQ;EAC1B,CAAC;EACD,CAAC7D,GAAG,CAACkE,YAAY,GAAG,CAACvD,OAAO,EAAEwC,UAAU,EAAEH,IAAI,KAAK;IACjD,MAAMa,QAAQ,GAAG,cAAc;IAC/B,MAAME,UAAU,GAAGF,QAAQ,IAAIlD,OAAO,CAAC8B,UAAU;IACjD,IAAI,CAACsB,UAAU,EAAE;MACfpD,OAAO,CAAC8B,UAAU,CAACoB,QAAQ,CAAC,GAAG;QAC7BG,IAAI,EAAEH,QAAQ;QACdb,IAAI,EAAE9C,UAAU;QAChBiE,SAAS,EAAGC,OAAO,IAAK;UACtB,OAAOjE,mBAAmB,CAACiE,OAAO,CAACC,WAAW,CAAC,CAAC,CAAC;QACnD;MACF,CAAC;IACH;IACA,MAAMJ,MAAM,GAAGtD,OAAO,CAAC4B,gBAAgB,GAAG,SAAS,GAAG,SAAS;IAC/D,OAAO0B,MAAM,GAAGJ,QAAQ;EAC1B,CAAC;EACD,CAAC7D,GAAG,CAACsE,UAAU,GAAG,MAAM,mBAAmB;EAAE;EAC7C,CAACtE,GAAG,CAACuE,GAAG,GAAG,CAAC5D,OAAO,EAAEwC,UAAU,KAAK;IAClC,MAAMS,QAAQ,GAAG,gCAAkCT,UAAU,CAACI,IAAI,CAAC,CAAC,CAAE;IACtE,MAAMiB,OAAO,GAAG,qBAAuBZ,QAAQ,CAACE,KAAM;IACtD,MAAMC,UAAU,GAAGS,OAAO,IAAI7D,OAAO,CAAC6B,SAAS;IAC/C,IAAI,CAACuB,UAAU,EAAE;MACfpD,OAAO,CAAC6B,SAAS,CAACgC,OAAO,CAAC,GAAG;QAC3BR,IAAI,EAAEQ,OAAO;QACbxB,IAAI,EAAEG,UAAU,CAACH;MACnB,CAAC;IACH;IACA,OAAOZ,sBAAsB,CAACoC,OAAO,CAAC;EACxC,CAAC;EACD,CAACxE,GAAG,CAACyE,UAAU,GAAG,MAAM,cAAc;EACtC,CAACzE,GAAG,CAAC0E,IAAI,GAAG,MAAM,QAAQ;EAC1B,CAAC1E,GAAG,CAAC2E,IAAI,GAAG,MAAM,QAAQ;EAC1B,CAAC3E,GAAG,CAAC4E,GAAG,GAAGvB,cAAc,CAAEwB,YAAY,IAAK,IAAIA,YAAY,CAACpD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;EAC7E,CAACzB,GAAG,CAAC8E,GAAG,GAAGzB,cAAc,CAAEwB,YAAY,IAAK,IAAIA,YAAY,CAACpD,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;EAC7E,CAACzB,GAAG,CAAC+E,GAAG,GAAG1B,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,KAAKA,KAAK,GAAG,CAAC;EACrD,CAAC9D,GAAG,CAACgF,KAAK,GAAG3B,cAAc,CACzB,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,OAAOC,WAAW,GACjE,CAAC;EACD,CAAClF,GAAG,CAACmF,QAAQ,GAAG9B,cAAc,CAC5B,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,OAAOC,WAAW,GACjE,CAAC;EACD,CAAClF,GAAG,CAACoF,WAAW,GAAG/B,cAAc,CAC/B,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,MAAMC,WAAW,GAChE,CAAC;EACD,CAAClF,GAAG,CAACqF,oBAAoB,GAAGhC,cAAc,CACxC,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,OAAOC,WAAW,GACjE,CAAC;EACD,CAAClF,GAAG,CAACsF,QAAQ,GAAGjC,cAAc,CAC5B,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,MAAMC,WAAW,GAChE,CAAC;EACD,CAAClF,GAAG,CAACuF,iBAAiB,GAAGlC,cAAc,CACrC,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,OAAOC,WAAW,GACjE,CAAC;EACD,CAAClF,GAAG,CAACwF,QAAQ,GAAGnC,cAAc,CAC3BwB,YAAY,IAAK,IAAIA,YAAY,CAACpD,IAAI,CAAC,KAAK,CAAC,GAChD,CAAC;EACD,CAACzB,GAAG,CAACyF,MAAM,GAAGpC,cAAc,CAC1B,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,MAAMC,WAAW,GAChE,CAAC;EACD,CAAClF,GAAG,CAAC0F,GAAG,GAAGrC,cAAc,CAAEwB,YAAY,IAAK,IAAIA,YAAY,CAACpD,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;EAC5E,CAACzB,GAAG,CAAC2F,QAAQ,GAAGtC,cAAc,CAC5B,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK,IAAID,UAAU,MAAMC,WAAW,GAChE,CAAC;EACD,CAAClF,GAAG,CAAC4F,KAAK,GAAGvC,cAAc,CACzB,CAAC,CAACS,KAAK,EAAE+B,GAAG,EAAEC,GAAG,CAAC,KAAK,SAAShC,KAAK,KAAK+B,GAAG,KAAKC,GAAG,GACvD,CAAC;EACD,CAAC9F,GAAG,CAAC+F,GAAG,GAAG1C,cAAc,CAAC,CAAC,CAACS,KAAK,EAAEkC,MAAM,CAAC,KAAK,OAAOlC,KAAK,KAAKkC,MAAM,GAAG,CAAC;EAC1E,CAAChG,GAAG,CAACiG,GAAG,GAAG5C,cAAc,CAAC,CAAC,CAACS,KAAK,EAAEoC,KAAK,CAAC,KAAK,OAAOpC,KAAK,KAAKoC,KAAK,GAAG,CAAC;EACxE,CAAClG,GAAG,CAACmG,GAAG,GAAG9C,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,OAAOA,KAAK,GAAG,CAAC;EACvD,CAAC9D,GAAG,CAACoG,KAAK,GAAG/C,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,SAASA,KAAK,GAAG,CAAC;EAC3D,CAAC9D,GAAG,CAACqG,IAAI,GAAGhD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,QAAQA,KAAK,GAAG,CAAC;EACzD,CAAC9D,GAAG,CAACsG,KAAK,GAAGjD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,SAASA,KAAK,SAAS,CAAC;EACjE,CAAC9D,GAAG,CAACuG,GAAG,GAAGlD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,OAAOA,KAAK,GAAG,CAAC;EACvD,CAAC9D,GAAG,CAACwG,GAAG,GAAGnD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,OAAOA,KAAK,GAAG,CAAC;EACvD,CAAC9D,GAAG,CAACyG,IAAI,GAAGpD,cAAc,CAAC,CAAC,CAAC4B,UAAU,EAAEC,WAAW,CAAC,KAAK;IACxD,OAAOA,WAAW,KAAKwB,SAAS,GAC5B,QAAQzB,UAAU,KAAKC,WAAW,GAAG,GACrC,QAAQD,UAAU,GAAG;EAC3B,CAAC,CAAC;EACF,CAACjF,GAAG,CAAC2G,IAAI,GAAGtD,cAAc,CAAC,CAAC,CAACS,KAAK,CAAC,KAAK,QAAQA,KAAK,GAAG,CAAC;EACzD,CAAC9D,GAAG,CAAC4G,KAAK,GAAGvD,cAAc,CAAEwB,YAAY,IAAK;IAC5C,MAAMgC,KAAK,GAAGhC,YAAY,CAAC,CAAC,CAAC;IAC7B,MAAMiC,QAAQ,GAAGjC,YAAY,CAACA,YAAY,CAAC9D,MAAM,GAAG,CAAC,CAAC;IACtD,IAAIgG,MAAM,GAAG,IAAI;IACjB,KAAK,IAAItD,CAAC,GAAGoB,YAAY,CAAC9D,MAAM,GAAG,CAAC,EAAE0C,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MACpD,MAAMuD,KAAK,GAAGnC,YAAY,CAACpB,CAAC,CAAC;MAC7B,MAAMH,MAAM,GAAGuB,YAAY,CAACpB,CAAC,GAAG,CAAC,CAAC;MAClCsD,MAAM,GAAG,IAAIF,KAAK,OAAOG,KAAK,MAAM1D,MAAM,MAAMyD,MAAM,IAAID,QAAQ,GAAG;IACvE;IACA,OAAOC,MAAM;EACf,CAAC,CAAC;EACF,CAAC/G,GAAG,CAACiH,OAAO,GAAG5D,cAAc,CAC3B,CAAC,CAACS,KAAK,EAAE+B,GAAG,EAAEC,GAAG,CAAC,KAAK,IAAIhC,KAAK,OAAO+B,GAAG,OAAO/B,KAAK,OAAOgC,GAAG,GAClE,CAAC;EACD,CAAC9F,GAAG,CAACkH,WAAW,GAAG7D,cAAc,CAAC,CAAC,CAAC8D,QAAQ,EAAEN,KAAK,EAAE,GAAGhC,YAAY,CAAC,KAAK;IACxE,IAAIkC,MAAM,GAAG,EAAE;IACf,KAAK,IAAItD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,YAAY,CAAC9D,MAAM,GAAG,CAAC,EAAE0C,CAAC,IAAI,CAAC,EAAE;MACnD,MAAM2D,KAAK,GAAGvC,YAAY,CAACpB,CAAC,CAAC;MAC7B,MAAM4D,OAAO,GAAGN,MAAM,IAAIlC,YAAY,CAACpB,CAAC,GAAG,CAAC,CAAC;MAC7C,MAAM6D,KAAK,GAAGzC,YAAY,CAACpB,CAAC,GAAG,CAAC,CAAC;MACjC,MAAM8D,OAAO,GAAG1C,YAAY,CAACpB,CAAC,GAAG,CAAC,CAAC;MACnC,IAAI+D,KAAK;MACT,IAAIL,QAAQ,KAAKnG,YAAY,CAAC,CAAC,CAAC,EAAE;QAChCwG,KAAK,GAAG,IAAIX,KAAK,MAAMO,KAAK,QAAQE,KAAK,MAAMF,KAAK,GAAG;MACzD,CAAC,MAAM;QACLI,KAAK,GAAG,QAAQL,QAAQ,MAAMN,KAAK,MAAMO,KAAK,oBAAoBD,QAAQ,MAAMG,KAAK,MAAMF,KAAK,WAAW;MAC7G;MACAL,MAAM,GAAG,OAAOM,OAAO,KAAKE,OAAO,WAAWC,KAAK,cAAc;IACnE;IACA,OAAOT,MAAM;EACf,CAAC,CAAC;EACF,CAAC/G,GAAG,CAACyH,IAAI,GAAGpE,cAAc,CAAEwB,YAAY,IAAK;IAC3C,MAAMiC,QAAQ,GAAGjC,YAAY,CAACA,YAAY,CAAC9D,MAAM,GAAG,CAAC,CAAC;IACtD,IAAIgG,MAAM,GAAG,IAAI;IACjB,KAAK,IAAItD,CAAC,GAAGoB,YAAY,CAAC9D,MAAM,GAAG,CAAC,EAAE0C,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;MACpD,MAAMiE,SAAS,GAAG7C,YAAY,CAACpB,CAAC,CAAC;MACjC,MAAMH,MAAM,GAAGuB,YAAY,CAACpB,CAAC,GAAG,CAAC,CAAC;MAClCsD,MAAM,GAAG,IAAIW,SAAS,MAAMpE,MAAM,MAAMyD,MAAM,IAAID,QAAQ,GAAG;IAC/D;IACA,OAAOC,MAAM;EACf,CAAC,CAAC;EACF,CAAC/G,GAAG,CAAC2H,EAAE,GAAGtE,cAAc,CAAC,CAAC,CAACuE,MAAM,EAAE,GAAGC,QAAQ,CAAC,EAAElH,OAAO,KAAK;IAC3D,MAAMmH,QAAQ,GAAGrH,2BAA2B,CAAC,IAAI,EAAEE,OAAO,CAAC;IAC3D,MAAMoH,KAAK,GAAG,EAAE;IAChB,KAAK,IAAItE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoE,QAAQ,CAAC9G,MAAM,EAAE0C,CAAC,IAAI,CAAC,EAAE;MAC3CsE,KAAK,CAACC,IAAI,CAAC,uBAAuBH,QAAQ,CAACpE,CAAC,CAAC,oBAAoB,CAAC;IACpE;IACA9C,OAAO,CAACG,SAAS,CAACgH,QAAQ,CAAC,GAAG,QAAQA,QAAQ;AAClD,EAAEC,KAAK,CAACtG,IAAI,CAAC,IAAI,CAAC;AAClB;AACA,EAAE;IACE,OAAO,GAAGqG,QAAQ,IAAIF,MAAM,GAAG;EACjC,CAAC,CAAC;EACF,CAAC5H,GAAG,CAACwD,KAAK,GAAGH,cAAc,CACxBE,IAAI,IAAK,MAAMA,IAAI,CAACxC,MAAM,IAAIwC,IAAI,CAAC9B,IAAI,CAAC,IAAI,CAAC,GAChD,CAAC;EACD,CAACzB,GAAG,CAACiI,KAAK,GAAG5E,cAAc,CAAEwB,YAAY,IAAK;IAC5C,IAAIA,YAAY,CAAC9D,MAAM,KAAK,CAAC,EAAE;MAC7B;MACA,OAAO,aAAa8D,YAAY,CAAC,CAAC,CAAC,iBAAiB;IACtD;IACA,IAAIA,YAAY,CAAC9D,MAAM,KAAK,CAAC,EAAE;MAC7B;MACA,OAAO,aAAa8D,YAAY,CAAC,CAAC,CAAC,cAAcA,YAAY,CAAC,CAAC,CAAC,GAAG;IACrE;IACA,MAAMqD,GAAG,GAAGrD,YAAY,CAACsD,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC3G,GAAG,CAAEG,KAAK,IAAK,GAAGA,KAAK,UAAU,CAAC;IACvE,IAAIkD,YAAY,CAAC9D,MAAM,KAAK,CAAC,EAAE;MAC7B,OAAO,QAAQmH,GAAG,CAACzG,IAAI,CAAC,IAAI,CAAC,QAAQ;IACvC;IACA,MAAMG,KAAK,GAAGiD,YAAY,CAAC,CAAC,CAAC;IAC7B,OAAO,QAAQqD,GAAG,CAACzG,IAAI,CAAC,IAAI,CAAC,KAAKG,KAAK,GAAG;EAC5C,CAAC,CAAC;EACF,CAAC5B,GAAG,CAACoI,IAAI,GAAG/E,cAAc,CAAC,CAAC,CAACgF,IAAI,EAAEC,OAAO,EAAEC,OAAO,CAAC,EAAE5H,OAAO,KAAK;IAChE,IAAI,EAAEiC,mBAAmB,IAAIjC,OAAO,CAACG,SAAS,CAAC,EAAE;MAC/C,IAAI0H,QAAQ,GAAG,EAAE;MACjB,MAAM9F,SAAS,GAAG/B,OAAO,CAAC+B,SAAS,IAAI,CAAC;MACxC,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,SAAS,EAAEe,CAAC,EAAE,EAAE;QAClC,MAAMgF,UAAU,GAAGC,IAAI,CAACC,KAAK,CAAClF,CAAC,GAAG,CAAC,CAAC;QACpC,IAAImF,SAAS,GAAGnF,CAAC,GAAG,CAAC;QACrB,IAAIA,CAAC,KAAKf,SAAS,GAAG,CAAC,IAAIkG,SAAS,KAAK,CAAC,EAAE;UAC1C;UACAA,SAAS,GAAG,CAAC;QACf;QACA,MAAMC,WAAW,GAAG,GAAGvI,QAAQ,CAACwI,kBAAkB,IAAIL,UAAU,GAAG;QACnED,QAAQ,IAAI,iBAAiB/E,CAAC,GAAG,CAAC;AAC1C,uBAAuBoF,WAAW,oCAAoCD,SAAS;AAC/E;AACA,CAAC;MACK;MAEAjI,OAAO,CAACG,SAAS,CAAC8B,mBAAmB,CAAC,GACpC;AACR,yBAAyBtC,QAAQ,CAACyI,mBAAmB;AACrD,yBAAyBzI,QAAQ,CAAC0I,oBAAoB;AACtD,EAAER,QAAQ;AACV,EAAE;IACE;IAEA,OAAO,GAAG5F,mBAAmB,IAAIyF,IAAI,KAAKC,OAAO,IAAI,KAAK,KACxDC,OAAO,IAAI,KAAK,GACf;EACL,CAAC,CAAC;EACF,CAACvI,GAAG,CAACiJ,OAAO,GAAG,CAACtI,OAAO,EAAEwC,UAAU,KAAK;IACtC,MAAM,CAAC+F,KAAK,EAAE,GAAGC,MAAM,CAAC,GAAGhG,UAAU,CAACI,IAAI;IAC1C,MAAM6F,SAAS,GAAGD,MAAM,CAACpI,MAAM;IAC/B,MAAMsI,OAAO,GAAG,IAAIC,UAAU,CAACF,SAAS,GAAG,CAAC,CAAC;IAC7C,KAAK,IAAI3F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0F,MAAM,CAACpI,MAAM,EAAE0C,CAAC,EAAE,EAAE;MACtC,MAAM8F,WAAW,GAAG;MAClB,gCAAkCJ,MAAM,CAAC1F,CAAC,CAAC,CAAEK,KAC9C;MACD,MAAMnC,KAAK,GAAGpB,OAAO,CAACgJ,WAAW,CAAC;MAClC,MAAMC,MAAM,GAAG/F,CAAC,GAAG,CAAC;MACpB4F,OAAO,CAACG,MAAM,CAAC,GAAG7H,KAAK,CAAC,CAAC,CAAC;MAC1B0H,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAG7H,KAAK,CAAC,CAAC,CAAC;MAC9B0H,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAG7H,KAAK,CAAC,CAAC,CAAC;MAC9B0H,OAAO,CAACG,MAAM,GAAG,CAAC,CAAC,GAAG7H,KAAK,CAAC,CAAC,CAAC,GAAG,GAAG;IACtC;IACA,IAAI,CAAChB,OAAO,CAAC8I,eAAe,EAAE;MAC5B9I,OAAO,CAAC8I,eAAe,GAAG,EAAE;IAC9B;IACA,MAAMC,WAAW,GAAG,GAAG7G,qBAAqB,IAAIlC,OAAO,CAAC8I,eAAe,CAAC1I,MAAM,GAAG;IACjF,MAAM4I,cAAc,GAAG,IAAIjK,cAAc,CAACgK,WAAW,EAAEL,OAAO,CAAC;IAC/D1I,OAAO,CAAC8I,eAAe,CAACzB,IAAI,CAAC2B,cAAc,CAAC;IAC5C,MAAMC,aAAa,GAAGxG,OAAO,CAAC8F,KAAK,EAAEnJ,UAAU,EAAEY,OAAO,CAAC;IACzD,OAAO,aAAa+I,WAAW,WAAWE,aAAa,aAAaR,SAAS,WAAW;EAC1F;EACA;EACA;EACA;EACA;EACA;EACA;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAAShG,OAAOA,CAACD,UAAU,EAAE0G,UAAU,EAAElJ,OAAO,EAAE;EAChD;EACA,IAAIwC,UAAU,YAAYvD,cAAc,EAAE;IACxC,MAAMkK,QAAQ,GAAGpG,SAAS,CAACP,UAAU,CAACzC,QAAQ,CAAC;IAC/C,IAAIoJ,QAAQ,KAAKpD,SAAS,EAAE;MAC1B,MAAM,IAAInF,KAAK,CACb,0CAA0CwI,IAAI,CAACC,SAAS,CACtD7G,UAAU,CAACzC,QACb,CAAC,EACH,CAAC;IACH;IACA,OAAOoJ,QAAQ,CAACnJ,OAAO,EAAEwC,UAAU,EAAE0G,UAAU,CAAC;EAClD;EAEA,IAAI,CAAC1G,UAAU,CAACH,IAAI,GAAGjD,UAAU,IAAI,CAAC,EAAE;IACtC,OAAOiB,YAAY,CAAC,qBAAuBmC,UAAU,CAACW,KAAM,CAAC;EAC/D;EAEA,IAAI,CAACX,UAAU,CAACH,IAAI,GAAGrD,WAAW,IAAI,CAAC,EAAE;IACvC,OAAOwD,UAAU,CAACW,KAAK,CAAC3C,QAAQ,CAAC,CAAC;EACpC;EAEA,IAAI,CAACgC,UAAU,CAACH,IAAI,GAAG9C,UAAU,IAAI,CAAC,EAAE;IACtC,OAAOiC,YAAY,CAACgB,UAAU,CAACW,KAAK,CAAC3C,QAAQ,CAAC,CAAC,CAAC;EAClD;EAEA,IAAI,CAACgC,UAAU,CAACH,IAAI,GAAGnD,SAAS,IAAI,CAAC,EAAE;IACrC,OAAO6B,WAAW,CAChB,qCAAuCyB,UAAU,CAACW,KACpD,CAAC;EACH;EAEA,IAAI,CAACX,UAAU,CAACH,IAAI,GAAGlD,eAAe,IAAI,CAAC,EAAE;IAC3C,OAAOuB,WAAW,CAAC,4BAA8B8B,UAAU,CAACW,KAAM,CAAC;EACrE;EAEA,IAAI,CAACX,UAAU,CAACH,IAAI,GAAG/C,QAAQ,IAAI,CAAC,EAAE;IACpC,OAAO4B,UAAU,CACf,+CAAiDsB,UAAU,CAACW,KAC9D,CAAC;EACH;EAEA,MAAM,IAAIvC,KAAK,CACb,yBAAyB4B,UAAU,CAACW,KAAK,mBAAmBzD,QAAQ,CAClEwJ,UACF,CAAC,GACH,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}