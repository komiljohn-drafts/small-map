{"ast":null,"code":"/**\n * @module ol/expr/cpu\n */\n\nimport { ColorType, LiteralExpression, Ops, parse } from './expression.js';\nimport { fromString, lchaToRgba, normalize, rgbaToLcha, toString, withAlpha } from '../color.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: ''\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, type, context);\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce:\n      {\n        return compileAssertionExpression(expression, context);\n      }\n    case Ops.Get:\n    case Ops.Var:\n    case Ops.Has:\n      {\n        return compileAccessorExpression(expression, context);\n      }\n    case Ops.Id:\n      {\n        return context => context.featureId;\n      }\n    case Ops.GeometryType:\n      {\n        return context => context.geometryType;\n      }\n    case Ops.Concat:\n      {\n        const args = expression.args.map(e => compileExpression(e, context));\n        return context => ''.concat(...args.map(arg => arg(context).toString()));\n      }\n    case Ops.Resolution:\n      {\n        return context => context.resolution;\n      }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Between:\n    case Ops.In:\n    case Ops.Not:\n      {\n        return compileLogicalExpression(expression, context);\n      }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return compileComparisonExpression(expression, context);\n      }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt:\n      {\n        return compileNumericExpression(expression, context);\n      }\n    case Ops.Case:\n      {\n        return compileCaseExpression(expression, context);\n      }\n    case Ops.Match:\n      {\n        return compileMatchExpression(expression, context);\n      }\n    case Ops.Interpolate:\n      {\n        return compileInterpolateExpression(expression, context);\n      }\n    case Ops.ToString:\n      {\n        return compileConvertExpression(expression, context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported operator ${operator}`);\n      }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Coalesce:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value !== 'undefined' && value !== null) {\n              return value;\n            }\n          }\n          throw new Error('Expected one of the values to be non-null');\n        };\n      }\n    case Ops.Number:\n    case Ops.String:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value === type) {\n              return value;\n            }\n          }\n          throw new Error(`Expected one of the values to be a ${type}`);\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported assertion operator ${type}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = /** @type {LiteralExpression} */expression.args[0];\n  const name = /** @type {string} */nameExpression.value;\n  switch (expression.operator) {\n    case Ops.Get:\n      {\n        return context => {\n          const args = expression.args;\n          let value = context.properties[name];\n          for (let i = 1, ii = args.length; i < ii; ++i) {\n            const keyExpression = /** @type {LiteralExpression} */args[i];\n            const key = /** @type {string|number} */keyExpression.value;\n            value = value[key];\n          }\n          return value;\n        };\n      }\n    case Ops.Var:\n      {\n        return context => context.variables[name];\n      }\n    case Ops.Has:\n      {\n        return context => {\n          const args = expression.args;\n          if (!(name in context.properties)) {\n            return false;\n          }\n          let value = context.properties[name];\n          for (let i = 1, ii = args.length; i < ii; ++i) {\n            const keyExpression = /** @type {LiteralExpression} */args[i];\n            const key = /** @type {string|number} */keyExpression.value;\n            if (!value || !Object.hasOwn(value, key)) {\n              return false;\n            }\n            value = value[key];\n          }\n          return true;\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported accessor operator ${expression.operator}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal:\n      {\n        return context => left(context) === right(context);\n      }\n    case Ops.NotEqual:\n      {\n        return context => left(context) !== right(context);\n      }\n    case Ops.LessThan:\n      {\n        return context => left(context) < right(context);\n      }\n    case Ops.LessThanOrEqualTo:\n      {\n        return context => left(context) <= right(context);\n      }\n    case Ops.GreaterThan:\n      {\n        return context => left(context) > right(context);\n      }\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return context => left(context) >= right(context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported comparison operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (args[i](context)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case Ops.All:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (!args[i](context)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n    case Ops.Between:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          const max = args[2](context);\n          return value >= min && value <= max;\n        };\n      }\n    case Ops.In:\n      {\n        return context => {\n          const value = args[0](context);\n          for (let i = 1; i < length; ++i) {\n            if (value === args[i](context)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case Ops.Not:\n      {\n        return context => !args[0](context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported logical operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply:\n      {\n        return context => {\n          let value = 1;\n          for (let i = 0; i < length; ++i) {\n            value *= args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Divide:\n      {\n        return context => args[0](context) / args[1](context);\n      }\n    case Ops.Add:\n      {\n        return context => {\n          let value = 0;\n          for (let i = 0; i < length; ++i) {\n            value += args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Subtract:\n      {\n        return context => args[0](context) - args[1](context);\n      }\n    case Ops.Clamp:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          if (value < min) {\n            return min;\n          }\n          const max = args[2](context);\n          if (value > max) {\n            return max;\n          }\n          return value;\n        };\n      }\n    case Ops.Mod:\n      {\n        return context => args[0](context) % args[1](context);\n      }\n    case Ops.Pow:\n      {\n        return context => Math.pow(args[0](context), args[1](context));\n      }\n    case Ops.Abs:\n      {\n        return context => Math.abs(args[0](context));\n      }\n    case Ops.Floor:\n      {\n        return context => Math.floor(args[0](context));\n      }\n    case Ops.Ceil:\n      {\n        return context => Math.ceil(args[0](context));\n      }\n    case Ops.Round:\n      {\n        return context => Math.round(args[0](context));\n      }\n    case Ops.Sin:\n      {\n        return context => Math.sin(args[0](context));\n      }\n    case Ops.Cos:\n      {\n        return context => Math.cos(args[0](context));\n      }\n    case Ops.Atan:\n      {\n        if (length === 2) {\n          return context => Math.atan2(args[0](context), args[1](context));\n        }\n        return context => Math.atan(args[0](context));\n      }\n    case Ops.Sqrt:\n      {\n        return context => Math.sqrt(args[0](context));\n      }\n    default:\n      {\n        throw new Error(`Unsupported numeric operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const base = args[0](context);\n    const value = args[1](context);\n    let previousInput;\n    let previousOutput;\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n      if (isColor) {\n        output = withAlpha(output);\n      }\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n        if (isColor) {\n          return interpolateColor(base, value, previousInput, previousOutput, input, output);\n        }\n        return interpolateNumber(base, value, previousInput, previousOutput, input, output);\n      }\n      previousInput = input;\n      previousOutput = output;\n    }\n    return previousOutput;\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileConvertExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.ToString:\n      {\n        return context => {\n          const value = args[0](context);\n          if (expression.args[0].type === ColorType) {\n            return toString(value);\n          }\n          return value.toString();\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported convert operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return output1;\n  }\n  const along = value - input1;\n  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return rgba1;\n  }\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n  const lcha = [interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]), interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]), lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue), interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])];\n  return normalize(lchaToRgba(lcha));\n}","map":{"version":3,"names":["ColorType","LiteralExpression","Ops","parse","fromString","lchaToRgba","normalize","rgbaToLcha","toString","withAlpha","newEvaluationContext","variables","properties","resolution","NaN","featureId","geometryType","buildExpression","encoded","type","context","expression","compileExpression","value","colorValue","operator","Number","String","Coalesce","compileAssertionExpression","Get","Var","Has","compileAccessorExpression","Id","GeometryType","Concat","args","map","e","concat","arg","Resolution","Any","All","Between","In","Not","compileLogicalExpression","Equal","NotEqual","LessThan","LessThanOrEqualTo","GreaterThan","GreaterThanOrEqualTo","compileComparisonExpression","Multiply","Divide","Add","Subtract","Clamp","Mod","Pow","Abs","Floor","Ceil","Round","Sin","Cos","Atan","Sqrt","compileNumericExpression","Case","compileCaseExpression","Match","compileMatchExpression","Interpolate","compileInterpolateExpression","ToString","compileConvertExpression","Error","length","Array","i","nameExpression","name","ii","keyExpression","key","Object","hasOwn","op","left","right","min","max","Math","pow","abs","floor","ceil","round","sin","cos","atan2","atan","sqrt","condition","base","previousInput","previousOutput","input","output","isColor","isArray","interpolateColor","interpolateNumber","input1","output1","input2","output2","delta","along","factor","rgba1","rgba2","lcha1","lcha2","deltaHue","lcha"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/expr/cpu.js"],"sourcesContent":["/**\n * @module ol/expr/cpu\n */\n\nimport {ColorType, LiteralExpression, Ops, parse} from './expression.js';\nimport {\n  fromString,\n  lchaToRgba,\n  normalize,\n  rgbaToLcha,\n  toString,\n  withAlpha,\n} from '../color.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: '',\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, type, context);\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce: {\n      return compileAssertionExpression(expression, context);\n    }\n    case Ops.Get:\n    case Ops.Var:\n    case Ops.Has: {\n      return compileAccessorExpression(expression, context);\n    }\n    case Ops.Id: {\n      return (context) => context.featureId;\n    }\n    case Ops.GeometryType: {\n      return (context) => context.geometryType;\n    }\n    case Ops.Concat: {\n      const args = expression.args.map((e) => compileExpression(e, context));\n      return (context) =>\n        ''.concat(...args.map((arg) => arg(context).toString()));\n    }\n    case Ops.Resolution: {\n      return (context) => context.resolution;\n    }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Between:\n    case Ops.In:\n    case Ops.Not: {\n      return compileLogicalExpression(expression, context);\n    }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo: {\n      return compileComparisonExpression(expression, context);\n    }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt: {\n      return compileNumericExpression(expression, context);\n    }\n    case Ops.Case: {\n      return compileCaseExpression(expression, context);\n    }\n    case Ops.Match: {\n      return compileMatchExpression(expression, context);\n    }\n    case Ops.Interpolate: {\n      return compileInterpolateExpression(expression, context);\n    }\n    case Ops.ToString: {\n      return compileConvertExpression(expression, context);\n    }\n    default: {\n      throw new Error(`Unsupported operator ${operator}`);\n    }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Coalesce: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value !== 'undefined' && value !== null) {\n            return value;\n          }\n        }\n        throw new Error('Expected one of the values to be non-null');\n      };\n    }\n    case Ops.Number:\n    case Ops.String: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          const value = args[i](context);\n          if (typeof value === type) {\n            return value;\n          }\n        }\n        throw new Error(`Expected one of the values to be a ${type}`);\n      };\n    }\n    default: {\n      throw new Error(`Unsupported assertion operator ${type}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = /** @type {LiteralExpression} */ (expression.args[0]);\n  const name = /** @type {string} */ (nameExpression.value);\n  switch (expression.operator) {\n    case Ops.Get: {\n      return (context) => {\n        const args = expression.args;\n        let value = context.properties[name];\n        for (let i = 1, ii = args.length; i < ii; ++i) {\n          const keyExpression = /** @type {LiteralExpression} */ (args[i]);\n          const key = /** @type {string|number} */ (keyExpression.value);\n          value = value[key];\n        }\n        return value;\n      };\n    }\n    case Ops.Var: {\n      return (context) => context.variables[name];\n    }\n    case Ops.Has: {\n      return (context) => {\n        const args = expression.args;\n        if (!(name in context.properties)) {\n          return false;\n        }\n        let value = context.properties[name];\n        for (let i = 1, ii = args.length; i < ii; ++i) {\n          const keyExpression = /** @type {LiteralExpression} */ (args[i]);\n          const key = /** @type {string|number} */ (keyExpression.value);\n          if (!value || !Object.hasOwn(value, key)) {\n            return false;\n          }\n          value = value[key];\n        }\n        return true;\n      };\n    }\n    default: {\n      throw new Error(`Unsupported accessor operator ${expression.operator}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal: {\n      return (context) => left(context) === right(context);\n    }\n    case Ops.NotEqual: {\n      return (context) => left(context) !== right(context);\n    }\n    case Ops.LessThan: {\n      return (context) => left(context) < right(context);\n    }\n    case Ops.LessThanOrEqualTo: {\n      return (context) => left(context) <= right(context);\n    }\n    case Ops.GreaterThan: {\n      return (context) => left(context) > right(context);\n    }\n    case Ops.GreaterThanOrEqualTo: {\n      return (context) => left(context) >= right(context);\n    }\n    default: {\n      throw new Error(`Unsupported comparison operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.All: {\n      return (context) => {\n        for (let i = 0; i < length; ++i) {\n          if (!args[i](context)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    }\n    case Ops.Between: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        const max = args[2](context);\n        return value >= min && value <= max;\n      };\n    }\n    case Ops.In: {\n      return (context) => {\n        const value = args[0](context);\n        for (let i = 1; i < length; ++i) {\n          if (value === args[i](context)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    }\n    case Ops.Not: {\n      return (context) => !args[0](context);\n    }\n    default: {\n      throw new Error(`Unsupported logical operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply: {\n      return (context) => {\n        let value = 1;\n        for (let i = 0; i < length; ++i) {\n          value *= args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Divide: {\n      return (context) => args[0](context) / args[1](context);\n    }\n    case Ops.Add: {\n      return (context) => {\n        let value = 0;\n        for (let i = 0; i < length; ++i) {\n          value += args[i](context);\n        }\n        return value;\n      };\n    }\n    case Ops.Subtract: {\n      return (context) => args[0](context) - args[1](context);\n    }\n    case Ops.Clamp: {\n      return (context) => {\n        const value = args[0](context);\n        const min = args[1](context);\n        if (value < min) {\n          return min;\n        }\n        const max = args[2](context);\n        if (value > max) {\n          return max;\n        }\n        return value;\n      };\n    }\n    case Ops.Mod: {\n      return (context) => args[0](context) % args[1](context);\n    }\n    case Ops.Pow: {\n      return (context) => Math.pow(args[0](context), args[1](context));\n    }\n    case Ops.Abs: {\n      return (context) => Math.abs(args[0](context));\n    }\n    case Ops.Floor: {\n      return (context) => Math.floor(args[0](context));\n    }\n    case Ops.Ceil: {\n      return (context) => Math.ceil(args[0](context));\n    }\n    case Ops.Round: {\n      return (context) => Math.round(args[0](context));\n    }\n    case Ops.Sin: {\n      return (context) => Math.sin(args[0](context));\n    }\n    case Ops.Cos: {\n      return (context) => Math.cos(args[0](context));\n    }\n    case Ops.Atan: {\n      if (length === 2) {\n        return (context) => Math.atan2(args[0](context), args[1](context));\n      }\n      return (context) => Math.atan(args[0](context));\n    }\n    case Ops.Sqrt: {\n      return (context) => Math.sqrt(args[0](context));\n    }\n    default: {\n      throw new Error(`Unsupported numeric operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return (context) => {\n    const base = args[0](context);\n    const value = args[1](context);\n\n    let previousInput;\n    let previousOutput;\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n      if (isColor) {\n        output = withAlpha(output);\n      }\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n        if (isColor) {\n          return interpolateColor(\n            base,\n            value,\n            previousInput,\n            previousOutput,\n            input,\n            output,\n          );\n        }\n        return interpolateNumber(\n          base,\n          value,\n          previousInput,\n          previousOutput,\n          input,\n          output,\n        );\n      }\n      previousInput = input;\n      previousOutput = output;\n    }\n    return previousOutput;\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileConvertExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.ToString: {\n      return (context) => {\n        const value = args[0](context);\n        if (expression.args[0].type === ColorType) {\n          return toString(value);\n        }\n        return value.toString();\n      };\n    }\n    default: {\n      throw new Error(`Unsupported convert operator ${op}`);\n    }\n  }\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return output1;\n  }\n  const along = value - input1;\n  const factor =\n    base === 1\n      ? along / delta\n      : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return rgba1;\n  }\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n\n  const lcha = [\n    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),\n    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),\n    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),\n    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3]),\n  ];\n  return normalize(lchaToRgba(lcha));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}