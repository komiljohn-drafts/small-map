{"ast":null,"code":"/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, { DECLUTTER } from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport { HIT_DETECT_RESOLUTION, createHitDetectionImageData, hitDetect } from '../../render/canvas/hitdetect.js';\nimport { apply as applyTransform, create as createTransform, multiply, reset as resetTransform, scale, scale as scaleTransform, translate as translateTransform } from '../../transform.js';\nimport { ascending } from '../../array.js';\nimport { boundingExtent, buffer, containsExtent, equals, getIntersection, getTopLeft, intersects } from '../../extent.js';\nimport { getSquaredTolerance as getSquaredRenderTolerance, renderFeature } from '../vector.js';\nimport { getUid } from '../../util.js';\nimport { toSize } from '../../size.js';\nimport { wrapX } from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': []\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default']\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(tile, frameState.pixelRatio, frameState.viewState.projection);\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */\n    this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (!builderState.dirty && builderState.renderedResolution === resolution && builderState.renderedRevision == revision && builderState.renderedRenderOrder == renderOrder) {\n      return;\n    }\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(sharedExtent, layer.getRenderBuffer() * resolution, this.tempExtent);\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent) ? null : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(0, sharedExtent, resolution, pixelRatio);\n      const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction = feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(feature, squaredTolerance, styles, builderGroup, declutter, index);\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (!bufferedExtent || intersects(bufferedExtent, feature.getGeometry().getExtent())) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent = layer.getRenderMode() !== 'vector' && declutter && sourceTiles.length === 1 ? null : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(replayExtent, resolution, pixelRatio, source.getOverlaps(), executorGroupInstructions, layer.getRenderBuffer(), true);\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(features[key] = {\n          feature: feature,\n          layer: layer,\n          geometry: geometry,\n          distanceSq: distanceSq,\n          callback: callback\n        });\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n    const renderedTiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutter = layer.getDeclutter();\n      executorGroups.some(executorGroups => {\n        const declutteredFeatures = declutter ? frameState.declutter[declutter].all().map(item => item.value) : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, declutteredFeatures);\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(this.renderedPixelToCoordinateTransform_, pixel.slice());\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(coordinate, resolution);\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */\n          this.renderedTiles[i];\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [(coordinate[0] - corner[0]) / resolution, (corner[1] - coordinate[1]) / resolution];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile.getSourceTiles().reduce(function (accumulator, sourceTile) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(tileGrid.getTileSize(tileGrid.getZForResolution(resolution, source.zDirection)));\n        const rotation = this.renderedRotation_;\n        const transforms = [this.getRenderTransform(tileGrid.getTileCoordCenter(tile.wrappedTileCoord), resolution, 0, HIT_DETECT_RESOLUTION, tileSize[0] * HIT_DETECT_RESOLUTION, tileSize[1] * HIT_DETECT_RESOLUTION, 0)];\n        hitDetectionImageData = createHitDetectionImageData(tileSize, transforms, features, layer.getStyleFunction(), tileGrid.getTileCoordExtent(tile.wrappedTileCoord), tile.getReplayState(layer).renderedResolution, rotation);\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const tileGrid = this.getLayer().getSource().tileGrid;\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    tileCache.forEach(tile => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    const tiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[getUid(this.getLayer())];\n      const declutter = this.getLayer().getDeclutter();\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(this.context, [this.context.canvas.width, this.context.canvas.height], this.getTileRenderTransform(tile, frameState), frameState.viewState.rotation, hifi, DECLUTTER, declutter ? frameState.declutter[declutter] : undefined);\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles = /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */\n    this.renderedTiles;\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[getUid(this.getLayer())].forEach(executorGroup => acc.push({\n        executorGroup,\n        index\n      }));\n      return acc;\n    }, []);\n    const executorGroupZIndexContexts = executorGroups.map(({\n      executorGroup\n    }) => executorGroup.getDeferredZIndexContexts());\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext = executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).sort(ascending);\n    zIndexKeys.map(Number).forEach(zIndex => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach(zIndexContext => {\n          const {\n            executorGroup,\n            index\n          } = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(frameState.viewState.projection);\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] - tileExtent[0];\n    const transform = multiply(scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio), this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, worldOffset));\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);\n    this.renderedPixelToCoordinateTransform_ = frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ = frameState.layerStatesArray[frameState.layerIndex].opacity;\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter ? VECTOR_REPLAYS[renderMode].filter(type => !DECLUTTER.includes(type)) : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(viewState.resolution, tileSource.zDirection);\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */\n      tiles[i];\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(group => group.hasExecutors(replayTypes));\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (intersects([currentClip[0], currentClip[3], currentClip[4], currentClip[7]], [clip[0], clip[3], clip[4], clip[7]])) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(context, [context.canvas.width, context.canvas.height], transform, rotation, hifi, replayTypes, frameState.declutter?.[declutter]);\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(feature, squaredTolerance, styles, builderGroup, declutter, index) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutter, index) || loading;\n      }\n    } else {\n      loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, undefined, declutter, index);\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return replayState.renderedTileResolution !== resolution || replayState.renderedTileRevision !== revision;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */\n    this.getLayer();\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio = frameState.pixelRatio / tile.wantedResolution * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(Math.max(pixelRatio, renderPixelRatio / pixelRatio));\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(context, [context.canvas.width * renderScale, context.canvas.height * renderScale], transform, 0, true, IMAGE_REPLAYS[layer.getRenderMode()], null);\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\nexport default CanvasVectorTileLayerRenderer;","map":{"version":3,"names":["CanvasBuilderGroup","CanvasExecutorGroup","DECLUTTER","CanvasTileLayerRenderer","TileState","ViewHint","ZIndexContext","HIT_DETECT_RESOLUTION","createHitDetectionImageData","hitDetect","apply","applyTransform","create","createTransform","multiply","reset","resetTransform","scale","scaleTransform","translate","translateTransform","ascending","boundingExtent","buffer","containsExtent","equals","getIntersection","getTopLeft","intersects","getSquaredTolerance","getSquaredRenderTolerance","renderFeature","getUid","toSize","wrapX","IMAGE_REPLAYS","VECTOR_REPLAYS","CanvasVectorTileLayerRenderer","constructor","layer","options","boundHandleStyleImageChange_","handleStyleImageChange_","bind","renderedLayerRevision_","renderedPixelToCoordinateTransform_","renderedRotation_","renderedOpacity_","tmpTransform_","tileClipContexts_","drawTile","tile","frameState","x","y","w","h","gutter","transition","updateExecutorGroup_","pixelRatio","viewState","projection","tileImageNeedsRender_","renderTileImage_","getTile","z","getOrCreateTile","resolution","viewHints","hifi","ANIMATING","INTERACTING","wantedResolution","prepareFrame","layerRevision","getLayer","getRevision","renderedTiles","length","revision","renderOrder","getRenderOrder","builderState","getReplayState","dirty","renderedResolution","renderedRevision","renderedRenderOrder","source","getSource","declutter","getDeclutter","sourceTileGrid","getTileGrid","tileGrid","getTileGridForProjection","tileExtent","getTileCoordExtent","wrappedTileCoord","sourceTiles","getSourceTiles","layerUid","hitDetectionImageData","executorGroups","t","tt","sourceTile","getState","LOADED","sourceTileCoord","tileCoord","sourceTileExtent","sharedExtent","builderExtent","getRenderBuffer","tempExtent","bufferedExtent","builderGroup","squaredTolerance","render","feature","index","styles","styleFunction","getStyleFunction","features","getFeatures","sort","i","ii","getGeometry","getExtent","call","executorGroupInstructions","finish","replayExtent","getRenderMode","renderingReplayGroup","getOverlaps","push","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","rotation","undefined","hitExtent","featureCallback","geometry","distanceSq","key","getId","match","splice","lastIndexOf","found","some","declutteredFeatures","all","map","item","value","executorGroup","pixel","Promise","resolve","reject","renderedProjection","projectionExtent","slice","getTileCoordForCoordAndResolution","toString","extent","getWrapX","canWrapX","loadingSourceTiles","corner","tilePixel","reduce","accumulator","concat","tileSize","getTileSize","getZForResolution","zDirection","transforms","getRenderTransform","getTileCoordCenter","getFeaturesInExtent","tileCache","getTileCache","getCount","forEach","tileFeatures","j","jj","candidate","handleFontsChanged","getVisible","changed","event","renderIfReadyAndVisible","renderDeclutter","layerState","context","alpha","globalAlpha","opacity","tiles","execute","canvas","width","height","getTileRenderTransform","renderDeferredInternal","acc","executorGroupZIndexContexts","getDeferredZIndexContexts","usedZIndices","executorGroupZindexContext","zIndexKeys","Object","keys","Number","zIndex","zIndexContexts","zIndexContext","getRenderedContext","tileClipContext","draw","restore","clear","center","size","Math","round","worldOffset","transform","inversePixelTransform","postRender","pixelToCoordinateTransform","layerStatesArray","layerIndex","renderMode","replayTypes","filter","type","includes","tileSource","clips","clipZs","tileClipContexts","ready","group","hasExecutors","currentZ","contextSaved","currentClip","getClipCoords","clipContext","getContext","clip","save","beginPath","moveTo","lineTo","loading","Array","isArray","replayState","renderedTileResolution","renderedTileRevision","tileResolution","getResolution","renderPixelRatio","max","getTilePixelSize","renderScale","canvasTransform","setTransform","pixelScale"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/renderer/canvas/VectorTileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorTileLayer\n */\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport CanvasExecutorGroup, {\n  DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport CanvasTileLayerRenderer from './TileLayer.js';\nimport TileState from '../../TileState.js';\nimport ViewHint from '../../ViewHint.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {\n  apply as applyTransform,\n  create as createTransform,\n  multiply,\n  reset as resetTransform,\n  scale,\n  scale as scaleTransform,\n  translate as translateTransform,\n} from '../../transform.js';\nimport {ascending} from '../../array.js';\nimport {\n  boundingExtent,\n  buffer,\n  containsExtent,\n  equals,\n  getIntersection,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {\n  getSquaredTolerance as getSquaredRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport {getUid} from '../../util.js';\nimport {toSize} from '../../size.js';\nimport {wrapX} from '../../coordinate.js';\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst IMAGE_REPLAYS = {\n  'image': ['Polygon', 'Circle', 'LineString', 'Image', 'Text'],\n  'hybrid': ['Polygon', 'LineString'],\n  'vector': [],\n};\n\n/**\n * @type {!Object<string, Array<import(\"../../render/canvas.js\").BuilderType>>}\n */\nconst VECTOR_REPLAYS = {\n  'hybrid': ['Image', 'Text', 'Default'],\n  'vector': ['Polygon', 'Circle', 'LineString', 'Image', 'Text', 'Default'],\n};\n\n/**\n * @classdesc\n * Canvas renderer for vector tile layers.\n * @api\n * @extends {CanvasTileLayerRenderer<import(\"../../layer/VectorTile.js\").default<import('../../source/VectorTile.js').default<import('../../Feature.js').FeatureLike>>>}\n */\nclass CanvasVectorTileLayerRenderer extends CanvasTileLayerRenderer {\n  /**\n   * @param {import(\"../../layer/VectorTile.js\").default} layer VectorTile layer.\n   * @param {import(\"./TileLayer.js\").Options} options Options.\n   */\n  constructor(layer, options) {\n    super(layer, options);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedLayerRevision_;\n\n    /**\n     * @private\n     * @type {import(\"../../transform\").Transform}\n     */\n    this.renderedPixelToCoordinateTransform_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedOpacity_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tmpTransform_ = createTransform();\n\n    /**\n     * @private\n     * @type {Array<ZIndexContext>}\n     */\n    this.tileClipContexts_ = null;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @override\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    this.updateExecutorGroup_(\n      tile,\n      frameState.pixelRatio,\n      frameState.viewState.projection,\n    );\n    if (this.tileImageNeedsRender_(tile)) {\n      this.renderTileImage_(tile, frameState);\n    }\n    super.drawTile(tile, frameState, x, y, w, h, gutter, transition);\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @override\n   */\n  getTile(z, x, y, frameState) {\n    const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n      this.getOrCreateTile(z, x, y, frameState)\n    );\n    if (!tile) {\n      return null;\n    }\n\n    const viewState = frameState.viewState;\n    const resolution = viewState.resolution;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    if (hifi || !tile.wantedResolution) {\n      tile.wantedResolution = resolution;\n    }\n    return tile;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const layerRevision = this.getLayer().getRevision();\n    if (this.renderedLayerRevision_ !== layerRevision) {\n      this.renderedLayerRevision_ = layerRevision;\n      this.renderedTiles.length = 0;\n    }\n    return super.prepareFrame(frameState);\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../../proj/Projection.js\").default} projection Projection.\n   * @private\n   */\n  updateExecutorGroup_(tile, pixelRatio, projection) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const revision = layer.getRevision();\n    const renderOrder = layer.getRenderOrder() || null;\n\n    const resolution = tile.wantedResolution;\n    const builderState = tile.getReplayState(layer);\n    if (\n      !builderState.dirty &&\n      builderState.renderedResolution === resolution &&\n      builderState.renderedRevision == revision &&\n      builderState.renderedRenderOrder == renderOrder\n    ) {\n      return;\n    }\n\n    const source = layer.getSource();\n    const declutter = !!layer.getDeclutter();\n    const sourceTileGrid = source.getTileGrid();\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n\n    const sourceTiles = source.getSourceTiles(pixelRatio, projection, tile);\n    const layerUid = getUid(layer);\n    delete tile.hitDetectionImageData[layerUid];\n    tile.executorGroups[layerUid] = [];\n    builderState.dirty = false;\n    for (let t = 0, tt = sourceTiles.length; t < tt; ++t) {\n      const sourceTile = sourceTiles[t];\n      if (sourceTile.getState() != TileState.LOADED) {\n        continue;\n      }\n      const sourceTileCoord = sourceTile.tileCoord;\n      const sourceTileExtent =\n        sourceTileGrid.getTileCoordExtent(sourceTileCoord);\n      const sharedExtent = getIntersection(tileExtent, sourceTileExtent);\n      const builderExtent = buffer(\n        sharedExtent,\n        layer.getRenderBuffer() * resolution,\n        this.tempExtent,\n      );\n      const bufferedExtent = equals(sourceTileExtent, sharedExtent)\n        ? null\n        : builderExtent;\n      const builderGroup = new CanvasBuilderGroup(\n        0,\n        sharedExtent,\n        resolution,\n        pixelRatio,\n      );\n      const squaredTolerance = getSquaredRenderTolerance(\n        resolution,\n        pixelRatio,\n      );\n\n      /**\n       * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n       * @param {number} [index] Render order index.\n       * @this {CanvasVectorTileLayerRenderer}\n       */\n      const render = function (feature, index) {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || layer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            builderGroup,\n            declutter,\n            index,\n          );\n          builderState.dirty = builderState.dirty || dirty;\n        }\n      };\n\n      const features = sourceTile.getFeatures();\n      if (renderOrder && renderOrder !== builderState.renderedRenderOrder) {\n        features.sort(renderOrder);\n      }\n      for (let i = 0, ii = features.length; i < ii; ++i) {\n        const feature = features[i];\n        if (\n          !bufferedExtent ||\n          intersects(bufferedExtent, feature.getGeometry().getExtent())\n        ) {\n          render.call(this, feature, i);\n        }\n      }\n      const executorGroupInstructions = builderGroup.finish();\n      // no need to clip when the render tile is covered by a single source tile\n      const replayExtent =\n        layer.getRenderMode() !== 'vector' &&\n        declutter &&\n        sourceTiles.length === 1\n          ? null\n          : sharedExtent;\n      const renderingReplayGroup = new CanvasExecutorGroup(\n        replayExtent,\n        resolution,\n        pixelRatio,\n        source.getOverlaps(),\n        executorGroupInstructions,\n        layer.getRenderBuffer(),\n        true,\n      );\n      tile.executorGroups[layerUid].push(renderingReplayGroup);\n    }\n    builderState.renderedRevision = revision;\n    builderState.renderedRenderOrder = renderOrder;\n    builderState.renderedResolution = resolution;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;\n    const layer = this.getLayer();\n    const source = layer.getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n\n    const hitExtent = boundingExtent([coordinate]);\n    buffer(hitExtent, resolution * hitTolerance, hitExtent);\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position.\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      let key = feature.getId();\n      if (key === undefined) {\n        key = getUid(feature);\n      }\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const renderedTiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n\n    let found;\n    for (let i = 0, ii = renderedTiles.length; !found && i < ii; ++i) {\n      const tile = renderedTiles[i];\n      const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      if (!intersects(tileExtent, hitExtent)) {\n        continue;\n      }\n\n      const layerUid = getUid(layer);\n      const executorGroups = [tile.executorGroups[layerUid]];\n      const declutter = layer.getDeclutter();\n      executorGroups.some((executorGroups) => {\n        const declutteredFeatures = declutter\n          ? frameState.declutter[declutter].all().map((item) => item.value)\n          : null;\n        for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n          const executorGroup = executorGroups[t];\n          found = executorGroup.forEachFeatureAtCoordinate(\n            coordinate,\n            resolution,\n            rotation,\n            hitTolerance,\n            featureCallback,\n            declutteredFeatures,\n          );\n          if (found) {\n            return true;\n          }\n        }\n      });\n    }\n    return found;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature.js\").FeatureLike>>} Promise that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve, reject) => {\n      const layer = this.getLayer();\n      const layerUid = getUid(layer);\n      const source = layer.getSource();\n      const projection = this.renderedProjection;\n      const projectionExtent = projection.getExtent();\n      const resolution = this.renderedResolution;\n      const tileGrid = source.getTileGridForProjection(projection);\n      const coordinate = applyTransform(\n        this.renderedPixelToCoordinateTransform_,\n        pixel.slice(),\n      );\n      const tileCoord = tileGrid.getTileCoordForCoordAndResolution(\n        coordinate,\n        resolution,\n      );\n      /** @type {import(\"../../VectorRenderTile.js\").default|undefined} */\n      let tile;\n      for (let i = 0, ii = this.renderedTiles.length; i < ii; ++i) {\n        if (\n          tileCoord.toString() === this.renderedTiles[i].tileCoord.toString()\n        ) {\n          tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n            this.renderedTiles[i]\n          );\n          if (tile.getState() === TileState.LOADED) {\n            const extent = tileGrid.getTileCoordExtent(tile.tileCoord);\n            if (\n              source.getWrapX() &&\n              projection.canWrapX() &&\n              !containsExtent(projectionExtent, extent)\n            ) {\n              wrapX(coordinate, projection);\n            }\n            break;\n          }\n          tile = undefined;\n        }\n      }\n      if (!tile || tile.loadingSourceTiles > 0) {\n        resolve([]);\n        return;\n      }\n      const extent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n      const corner = getTopLeft(extent);\n      const tilePixel = [\n        (coordinate[0] - corner[0]) / resolution,\n        (corner[1] - coordinate[1]) / resolution,\n      ];\n      /** @type {Array<import(\"../../Feature.js\").FeatureLike>} */\n      const features = tile.getSourceTiles().reduce(function (\n        accumulator,\n        sourceTile,\n      ) {\n        return accumulator.concat(sourceTile.getFeatures());\n      }, []);\n      /** @type {ImageData|undefined} */\n      let hitDetectionImageData = tile.hitDetectionImageData[layerUid];\n      if (!hitDetectionImageData) {\n        const tileSize = toSize(\n          tileGrid.getTileSize(\n            tileGrid.getZForResolution(resolution, source.zDirection),\n          ),\n        );\n        const rotation = this.renderedRotation_;\n        const transforms = [\n          this.getRenderTransform(\n            tileGrid.getTileCoordCenter(tile.wrappedTileCoord),\n            resolution,\n            0,\n            HIT_DETECT_RESOLUTION,\n            tileSize[0] * HIT_DETECT_RESOLUTION,\n            tileSize[1] * HIT_DETECT_RESOLUTION,\n            0,\n          ),\n        ];\n        hitDetectionImageData = createHitDetectionImageData(\n          tileSize,\n          transforms,\n          features,\n          layer.getStyleFunction(),\n          tileGrid.getTileCoordExtent(tile.wrappedTileCoord),\n          tile.getReplayState(layer).renderedResolution,\n          rotation,\n        );\n        tile.hitDetectionImageData[layerUid] = hitDetectionImageData;\n      }\n      resolve(hitDetect(tilePixel, features, hitDetectionImageData));\n    });\n  }\n\n  /**\n   * @param {import(\"../../extent.js\").Extent} extent Extent.\n   * @return {Array<import('../../Feature.js').FeatureLike>} Features.\n   */\n  getFeaturesInExtent(extent) {\n    const features = [];\n    const tileCache = this.getTileCache();\n    if (tileCache.getCount() === 0) {\n      return features;\n    }\n    const tileGrid = this.getLayer().getSource().tileGrid;\n    const z = tileGrid.getZForResolution(this.renderedResolution);\n    tileCache.forEach((tile) => {\n      if (tile.tileCoord[0] !== z || tile.getState() !== TileState.LOADED) {\n        return;\n      }\n      const sourceTiles = tile.getSourceTiles();\n      for (let i = 0, ii = sourceTiles.length; i < ii; ++i) {\n        const sourceTile = sourceTiles[i];\n        const tileCoord = sourceTile.tileCoord;\n        if (intersects(extent, tileGrid.getTileCoordExtent(tileCoord))) {\n          const tileFeatures = sourceTile.getFeatures();\n          if (tileFeatures) {\n            for (let j = 0, jj = tileFeatures.length; j < jj; ++j) {\n              const candidate = tileFeatures[j];\n              const geometry = candidate.getGeometry();\n              if (intersects(extent, geometry.getExtent())) {\n                features.push(candidate);\n              }\n            }\n          }\n        }\n      }\n    });\n    return features;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../layer/Layer.js\").State} layerState Layer state.\n   */\n  renderDeclutter(frameState, layerState) {\n    const context = this.context;\n    const alpha = context.globalAlpha;\n    context.globalAlpha = layerState.opacity;\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    for (let i = 0, ii = tiles.length; i < ii; ++i) {\n      const tile = tiles[i];\n      const executorGroups = tile.executorGroups[getUid(this.getLayer())];\n      const declutter = this.getLayer().getDeclutter();\n      if (executorGroups) {\n        for (let j = executorGroups.length - 1; j >= 0; --j) {\n          executorGroups[j].execute(\n            this.context,\n            [this.context.canvas.width, this.context.canvas.height],\n            this.getTileRenderTransform(tile, frameState),\n            frameState.viewState.rotation,\n            hifi,\n            DECLUTTER,\n            declutter ? frameState.declutter[declutter] : undefined,\n          );\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    const tiles =\n      /** @type {Array<import(\"../../VectorRenderTile.js\").default>} */ (\n        this.renderedTiles\n      );\n    const executorGroups = tiles.reduce((acc, tile, index) => {\n      tile.executorGroups[getUid(this.getLayer())].forEach((executorGroup) =>\n        acc.push({\n          executorGroup,\n          index,\n        }),\n      );\n      return acc;\n    }, []);\n\n    const executorGroupZIndexContexts = executorGroups.map(({executorGroup}) =>\n      executorGroup.getDeferredZIndexContexts(),\n    );\n    const usedZIndices = {};\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroupZindexContext =\n        executorGroups[i].executorGroup.getDeferredZIndexContexts();\n      for (const key in executorGroupZindexContext) {\n        usedZIndices[key] = true;\n      }\n    }\n    const zIndexKeys = Object.keys(usedZIndices).sort(ascending);\n    zIndexKeys.map(Number).forEach((zIndex) => {\n      executorGroupZIndexContexts.forEach((zIndexContexts, i) => {\n        if (!zIndexContexts[zIndex]) {\n          return;\n        }\n        zIndexContexts[zIndex].forEach((zIndexContext) => {\n          const {executorGroup, index} = executorGroups[i];\n          const context = executorGroup.getRenderedContext();\n          const alpha = context.globalAlpha;\n          context.globalAlpha = this.renderedOpacity_;\n          const tileClipContext = this.tileClipContexts_[index];\n          if (tileClipContext) {\n            tileClipContext.draw(context);\n          }\n          zIndexContext.draw(context);\n          if (tileClipContext) {\n            context.restore();\n          }\n          context.globalAlpha = alpha;\n          zIndexContext.clear();\n        });\n        zIndexContexts[zIndex].length = 0;\n      });\n    });\n  }\n\n  getTileRenderTransform(tile, frameState) {\n    const pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const rotation = viewState.rotation;\n    const size = frameState.size;\n    const width = Math.round(size[0] * pixelRatio);\n    const height = Math.round(size[1] * pixelRatio);\n\n    const source = this.getLayer().getSource();\n    const tileGrid = source.getTileGridForProjection(\n      frameState.viewState.projection,\n    );\n    const tileCoord = tile.tileCoord;\n    const tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);\n    const worldOffset =\n      tileGrid.getTileCoordExtent(tileCoord, this.tempExtent)[0] -\n      tileExtent[0];\n    const transform = multiply(\n      scale(this.inversePixelTransform.slice(), 1 / pixelRatio, 1 / pixelRatio),\n      this.getRenderTransform(\n        center,\n        resolution,\n        rotation,\n        pixelRatio,\n        width,\n        height,\n        worldOffset,\n      ),\n    );\n    return transform;\n  }\n\n  /**\n   * Render the vectors for this layer.\n   * @param {CanvasRenderingContext2D} context Target context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  postRender(context, frameState) {\n    const viewHints = frameState.viewHints;\n    const hifi = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n\n    this.renderedPixelToCoordinateTransform_ =\n      frameState.pixelToCoordinateTransform.slice();\n    this.renderedRotation_ = frameState.viewState.rotation;\n    this.renderedOpacity_ =\n      frameState.layerStatesArray[frameState.layerIndex].opacity;\n\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const renderMode = layer.getRenderMode();\n    const alpha = context.globalAlpha;\n    context.globalAlpha = this.renderedOpacity_;\n    const declutter = layer.getDeclutter();\n    const replayTypes = declutter\n      ? VECTOR_REPLAYS[renderMode].filter((type) => !DECLUTTER.includes(type))\n      : VECTOR_REPLAYS[renderMode];\n    const viewState = frameState.viewState;\n    const rotation = viewState.rotation;\n    const tileSource = layer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n    const z = tileGrid.getZForResolution(\n      viewState.resolution,\n      tileSource.zDirection,\n    );\n\n    const tiles = this.renderedTiles;\n    const clips = [];\n    const clipZs = [];\n    const tileClipContexts = [];\n    let ready = true;\n    for (let i = tiles.length - 1; i >= 0; --i) {\n      const tile = /** @type {import(\"../../VectorRenderTile.js\").default} */ (\n        tiles[i]\n      );\n      ready = ready && !tile.getReplayState(layer).dirty;\n      const executorGroups = tile.executorGroups[getUid(layer)].filter(\n        (group) => group.hasExecutors(replayTypes),\n      );\n      if (executorGroups.length === 0) {\n        continue;\n      }\n      const transform = this.getTileRenderTransform(tile, frameState);\n      const currentZ = tile.tileCoord[0];\n      let contextSaved = false;\n      // Clip mask for regions in this tile that already filled by a higher z tile\n      const currentClip = executorGroups[0].getClipCoords(transform);\n      let clipContext = context;\n      let tileClipContext;\n      if (currentClip) {\n        tileClipContext = new ZIndexContext();\n        clipContext = tileClipContext.getContext();\n        for (let j = 0, jj = clips.length; j < jj; ++j) {\n          if (z !== currentZ && currentZ < clipZs[j]) {\n            const clip = clips[j];\n            if (\n              intersects(\n                [\n                  currentClip[0],\n                  currentClip[3],\n                  currentClip[4],\n                  currentClip[7],\n                ],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                clipContext.save();\n                contextSaved = true;\n              }\n              clipContext.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              clipContext.moveTo(currentClip[0], currentClip[1]);\n              clipContext.lineTo(currentClip[2], currentClip[3]);\n              clipContext.lineTo(currentClip[4], currentClip[5]);\n              clipContext.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              clipContext.moveTo(clip[6], clip[7]);\n              clipContext.lineTo(clip[4], clip[5]);\n              clipContext.lineTo(clip[2], clip[3]);\n              clipContext.lineTo(clip[0], clip[1]);\n              clipContext.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n      }\n      for (let t = 0, tt = executorGroups.length; t < tt; ++t) {\n        const executorGroup = executorGroups[t];\n        executorGroup.execute(\n          context,\n          [context.canvas.width, context.canvas.height],\n          transform,\n          rotation,\n          hifi,\n          replayTypes,\n          frameState.declutter?.[declutter],\n        );\n      }\n      if (contextSaved) {\n        if (clipContext === context) {\n          clipContext.restore();\n        } else {\n          tileClipContexts[i] = tileClipContext;\n        }\n      }\n    }\n    context.globalAlpha = alpha;\n    this.ready = ready;\n    this.tileClipContexts_ = tileClipContexts;\n    if (!frameState.declutter) {\n      this.renderDeferredInternal(frameState);\n    }\n\n    super.postRender(context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            undefined,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        undefined,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @return {boolean} A new tile image was rendered.\n   * @private\n   */\n  tileImageNeedsRender_(tile) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    if (layer.getRenderMode() === 'vector') {\n      return false;\n    }\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const resolution = tile.wantedResolution;\n    return (\n      replayState.renderedTileResolution !== resolution ||\n      replayState.renderedTileRevision !== revision\n    );\n  }\n\n  /**\n   * @param {import(\"../../VectorRenderTile.js\").default} tile Tile.\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @private\n   */\n  renderTileImage_(tile, frameState) {\n    const layer = /** @type {import(\"../../layer/VectorTile.js\").default} */ (\n      this.getLayer()\n    );\n    const replayState = tile.getReplayState(layer);\n    const revision = layer.getRevision();\n    const executorGroups = tile.executorGroups[getUid(layer)];\n    replayState.renderedTileRevision = revision;\n\n    const tileCoord = tile.wrappedTileCoord;\n    const z = tileCoord[0];\n    const source = layer.getSource();\n    let pixelRatio = frameState.pixelRatio;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const tileGrid = source.getTileGridForProjection(projection);\n    const tileResolution = tileGrid.getResolution(tile.tileCoord[0]);\n    const renderPixelRatio =\n      (frameState.pixelRatio / tile.wantedResolution) * tileResolution;\n    const resolution = tileGrid.getResolution(z);\n    const context = tile.getContext();\n\n    // Increase tile size when overzooming for low pixel ratio, to avoid blurry tiles\n    pixelRatio = Math.round(\n      Math.max(pixelRatio, renderPixelRatio / pixelRatio),\n    );\n    const size = source.getTilePixelSize(z, pixelRatio, projection);\n    context.canvas.width = size[0];\n    context.canvas.height = size[1];\n    const renderScale = pixelRatio / renderPixelRatio;\n    if (renderScale !== 1) {\n      const canvasTransform = resetTransform(this.tmpTransform_);\n      scaleTransform(canvasTransform, renderScale, renderScale);\n      context.setTransform.apply(context, canvasTransform);\n    }\n    const tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tempExtent);\n    const pixelScale = renderPixelRatio / resolution;\n    const transform = resetTransform(this.tmpTransform_);\n    scaleTransform(transform, pixelScale, -pixelScale);\n    translateTransform(transform, -tileExtent[0], -tileExtent[3]);\n    for (let i = 0, ii = executorGroups.length; i < ii; ++i) {\n      const executorGroup = executorGroups[i];\n      executorGroup.execute(\n        context,\n        [\n          context.canvas.width * renderScale,\n          context.canvas.height * renderScale,\n        ],\n        transform,\n        0,\n        true,\n        IMAGE_REPLAYS[layer.getRenderMode()],\n        null,\n      );\n    }\n    replayState.renderedTileResolution = tile.wantedResolution;\n  }\n}\n\nexport default CanvasVectorTileLayerRenderer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}