{"ast":null,"code":"import quickselect from 'quickselect';\nexport default class RBush {\n  constructor(maxEntries = 9) {\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n    this.clear();\n  }\n  all() {\n    return this._all(this.data, []);\n  }\n  search(bbox) {\n    let node = this.data;\n    const result = [];\n    if (!intersects(bbox, node)) return result;\n    const toBBox = this.toBBox;\n    const nodesToSearch = [];\n    while (node) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        const childBBox = node.leaf ? toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return result;\n  }\n  collides(bbox) {\n    let node = this.data;\n    if (!intersects(bbox, node)) return false;\n    const nodesToSearch = [];\n    while (node) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        const childBBox = node.leaf ? this.toBBox(child) : child;\n        if (intersects(bbox, childBBox)) {\n          if (node.leaf || contains(bbox, childBBox)) return true;\n          nodesToSearch.push(child);\n        }\n      }\n      node = nodesToSearch.pop();\n    }\n    return false;\n  }\n  load(data) {\n    if (!(data && data.length)) return this;\n    if (data.length < this._minEntries) {\n      for (let i = 0; i < data.length; i++) {\n        this.insert(data[i]);\n      }\n      return this;\n    }\n\n    // recursively build the tree with the given data from scratch using OMT algorithm\n    let node = this._build(data.slice(), 0, data.length - 1, 0);\n    if (!this.data.children.length) {\n      // save as is if tree is empty\n      this.data = node;\n    } else if (this.data.height === node.height) {\n      // split root if trees have the same height\n      this._splitRoot(this.data, node);\n    } else {\n      if (this.data.height < node.height) {\n        // swap trees if inserted one is bigger\n        const tmpNode = this.data;\n        this.data = node;\n        node = tmpNode;\n      }\n\n      // insert the small tree into the large tree at appropriate level\n      this._insert(node, this.data.height - node.height - 1, true);\n    }\n    return this;\n  }\n  insert(item) {\n    if (item) this._insert(item, this.data.height - 1);\n    return this;\n  }\n  clear() {\n    this.data = createNode([]);\n    return this;\n  }\n  remove(item, equalsFn) {\n    if (!item) return this;\n    let node = this.data;\n    const bbox = this.toBBox(item);\n    const path = [];\n    const indexes = [];\n    let i, parent, goingUp;\n\n    // depth-first iterative tree traversal\n    while (node || path.length) {\n      if (!node) {\n        // go up\n        node = path.pop();\n        parent = path[path.length - 1];\n        i = indexes.pop();\n        goingUp = true;\n      }\n      if (node.leaf) {\n        // check current node\n        const index = findItem(item, node.children, equalsFn);\n        if (index !== -1) {\n          // item found, remove the item and condense tree upwards\n          node.children.splice(index, 1);\n          path.push(node);\n          this._condense(path);\n          return this;\n        }\n      }\n      if (!goingUp && !node.leaf && contains(node, bbox)) {\n        // go down\n        path.push(node);\n        indexes.push(i);\n        i = 0;\n        parent = node;\n        node = node.children[0];\n      } else if (parent) {\n        // go right\n        i++;\n        node = parent.children[i];\n        goingUp = false;\n      } else node = null; // nothing found\n    }\n    return this;\n  }\n  toBBox(item) {\n    return item;\n  }\n  compareMinX(a, b) {\n    return a.minX - b.minX;\n  }\n  compareMinY(a, b) {\n    return a.minY - b.minY;\n  }\n  toJSON() {\n    return this.data;\n  }\n  fromJSON(data) {\n    this.data = data;\n    return this;\n  }\n  _all(node, result) {\n    const nodesToSearch = [];\n    while (node) {\n      if (node.leaf) result.push(...node.children);else nodesToSearch.push(...node.children);\n      node = nodesToSearch.pop();\n    }\n    return result;\n  }\n  _build(items, left, right, height) {\n    const N = right - left + 1;\n    let M = this._maxEntries;\n    let node;\n    if (N <= M) {\n      // reached leaf level; return leaf\n      node = createNode(items.slice(left, right + 1));\n      calcBBox(node, this.toBBox);\n      return node;\n    }\n    if (!height) {\n      // target height of the bulk-loaded tree\n      height = Math.ceil(Math.log(N) / Math.log(M));\n\n      // target number of root entries to maximize storage utilization\n      M = Math.ceil(N / Math.pow(M, height - 1));\n    }\n    node = createNode([]);\n    node.leaf = false;\n    node.height = height;\n\n    // split the items into M mostly square tiles\n\n    const N2 = Math.ceil(N / M);\n    const N1 = N2 * Math.ceil(Math.sqrt(M));\n    multiSelect(items, left, right, N1, this.compareMinX);\n    for (let i = left; i <= right; i += N1) {\n      const right2 = Math.min(i + N1 - 1, right);\n      multiSelect(items, i, right2, N2, this.compareMinY);\n      for (let j = i; j <= right2; j += N2) {\n        const right3 = Math.min(j + N2 - 1, right2);\n\n        // pack each entry recursively\n        node.children.push(this._build(items, j, right3, height - 1));\n      }\n    }\n    calcBBox(node, this.toBBox);\n    return node;\n  }\n  _chooseSubtree(bbox, node, level, path) {\n    while (true) {\n      path.push(node);\n      if (node.leaf || path.length - 1 === level) break;\n      let minArea = Infinity;\n      let minEnlargement = Infinity;\n      let targetNode;\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        const area = bboxArea(child);\n        const enlargement = enlargedArea(bbox, child) - area;\n\n        // choose entry with the least area enlargement\n        if (enlargement < minEnlargement) {\n          minEnlargement = enlargement;\n          minArea = area < minArea ? area : minArea;\n          targetNode = child;\n        } else if (enlargement === minEnlargement) {\n          // otherwise choose one with the smallest area\n          if (area < minArea) {\n            minArea = area;\n            targetNode = child;\n          }\n        }\n      }\n      node = targetNode || node.children[0];\n    }\n    return node;\n  }\n  _insert(item, level, isNode) {\n    const bbox = isNode ? item : this.toBBox(item);\n    const insertPath = [];\n\n    // find the best node for accommodating the item, saving all nodes along the path too\n    const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n    // put the item into the node\n    node.children.push(item);\n    extend(node, bbox);\n\n    // split on node overflow; propagate upwards if necessary\n    while (level >= 0) {\n      if (insertPath[level].children.length > this._maxEntries) {\n        this._split(insertPath, level);\n        level--;\n      } else break;\n    }\n\n    // adjust bboxes along the insertion path\n    this._adjustParentBBoxes(bbox, insertPath, level);\n  }\n\n  // split overflowed node into two\n  _split(insertPath, level) {\n    const node = insertPath[level];\n    const M = node.children.length;\n    const m = this._minEntries;\n    this._chooseSplitAxis(node, m, M);\n    const splitIndex = this._chooseSplitIndex(node, m, M);\n    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n    newNode.height = node.height;\n    newNode.leaf = node.leaf;\n    calcBBox(node, this.toBBox);\n    calcBBox(newNode, this.toBBox);\n    if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);\n  }\n  _splitRoot(node, newNode) {\n    // split root node\n    this.data = createNode([node, newNode]);\n    this.data.height = node.height + 1;\n    this.data.leaf = false;\n    calcBBox(this.data, this.toBBox);\n  }\n  _chooseSplitIndex(node, m, M) {\n    let index;\n    let minOverlap = Infinity;\n    let minArea = Infinity;\n    for (let i = m; i <= M - m; i++) {\n      const bbox1 = distBBox(node, 0, i, this.toBBox);\n      const bbox2 = distBBox(node, i, M, this.toBBox);\n      const overlap = intersectionArea(bbox1, bbox2);\n      const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n      // choose distribution with minimum overlap\n      if (overlap < minOverlap) {\n        minOverlap = overlap;\n        index = i;\n        minArea = area < minArea ? area : minArea;\n      } else if (overlap === minOverlap) {\n        // otherwise choose distribution with minimum area\n        if (area < minArea) {\n          minArea = area;\n          index = i;\n        }\n      }\n    }\n    return index || M - m;\n  }\n\n  // sorts node children by the best axis for split\n  _chooseSplitAxis(node, m, M) {\n    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n    const xMargin = this._allDistMargin(node, m, M, compareMinX);\n    const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n    // if total distributions margin value is minimal for x, sort by minX,\n    // otherwise it's already sorted by minY\n    if (xMargin < yMargin) node.children.sort(compareMinX);\n  }\n\n  // total margin of all possible split distributions where each node is at least m full\n  _allDistMargin(node, m, M, compare) {\n    node.children.sort(compare);\n    const toBBox = this.toBBox;\n    const leftBBox = distBBox(node, 0, m, toBBox);\n    const rightBBox = distBBox(node, M - m, M, toBBox);\n    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n    for (let i = m; i < M - m; i++) {\n      const child = node.children[i];\n      extend(leftBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(leftBBox);\n    }\n    for (let i = M - m - 1; i >= m; i--) {\n      const child = node.children[i];\n      extend(rightBBox, node.leaf ? toBBox(child) : child);\n      margin += bboxMargin(rightBBox);\n    }\n    return margin;\n  }\n  _adjustParentBBoxes(bbox, path, level) {\n    // adjust bboxes along the given tree path\n    for (let i = level; i >= 0; i--) {\n      extend(path[i], bbox);\n    }\n  }\n  _condense(path) {\n    // go through the path, removing empty nodes and updating bboxes\n    for (let i = path.length - 1, siblings; i >= 0; i--) {\n      if (path[i].children.length === 0) {\n        if (i > 0) {\n          siblings = path[i - 1].children;\n          siblings.splice(siblings.indexOf(path[i]), 1);\n        } else this.clear();\n      } else calcBBox(path[i], this.toBBox);\n    }\n  }\n}\nfunction findItem(item, items, equalsFn) {\n  if (!equalsFn) return items.indexOf(item);\n  for (let i = 0; i < items.length; i++) {\n    if (equalsFn(item, items[i])) return i;\n  }\n  return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n  distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n  if (!destNode) destNode = createNode(null);\n  destNode.minX = Infinity;\n  destNode.minY = Infinity;\n  destNode.maxX = -Infinity;\n  destNode.maxY = -Infinity;\n  for (let i = k; i < p; i++) {\n    const child = node.children[i];\n    extend(destNode, node.leaf ? toBBox(child) : child);\n  }\n  return destNode;\n}\nfunction extend(a, b) {\n  a.minX = Math.min(a.minX, b.minX);\n  a.minY = Math.min(a.minY, b.minY);\n  a.maxX = Math.max(a.maxX, b.maxX);\n  a.maxY = Math.max(a.maxY, b.maxY);\n  return a;\n}\nfunction compareNodeMinX(a, b) {\n  return a.minX - b.minX;\n}\nfunction compareNodeMinY(a, b) {\n  return a.minY - b.minY;\n}\nfunction bboxArea(a) {\n  return (a.maxX - a.minX) * (a.maxY - a.minY);\n}\nfunction bboxMargin(a) {\n  return a.maxX - a.minX + (a.maxY - a.minY);\n}\nfunction enlargedArea(a, b) {\n  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\nfunction intersectionArea(a, b) {\n  const minX = Math.max(a.minX, b.minX);\n  const minY = Math.max(a.minY, b.minY);\n  const maxX = Math.min(a.maxX, b.maxX);\n  const maxY = Math.min(a.maxY, b.maxY);\n  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);\n}\nfunction contains(a, b) {\n  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;\n}\nfunction intersects(a, b) {\n  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;\n}\nfunction createNode(children) {\n  return {\n    children,\n    height: 1,\n    leaf: true,\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity\n  };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n  const stack = [left, right];\n  while (stack.length) {\n    right = stack.pop();\n    left = stack.pop();\n    if (right - left <= n) continue;\n    const mid = left + Math.ceil((right - left) / n / 2) * n;\n    quickselect(arr, mid, left, right, compare);\n    stack.push(left, mid, mid, right);\n  }\n}","map":{"version":3,"names":["quickselect","RBush","constructor","maxEntries","_maxEntries","Math","max","_minEntries","ceil","clear","all","_all","data","search","bbox","node","result","intersects","toBBox","nodesToSearch","i","children","length","child","childBBox","leaf","push","contains","pop","collides","load","insert","_build","slice","height","_splitRoot","tmpNode","_insert","item","createNode","remove","equalsFn","path","indexes","parent","goingUp","index","findItem","splice","_condense","compareMinX","a","b","minX","compareMinY","minY","toJSON","fromJSON","items","left","right","N","M","calcBBox","log","pow","N2","N1","sqrt","multiSelect","right2","min","j","right3","_chooseSubtree","level","minArea","Infinity","minEnlargement","targetNode","area","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","_split","_adjustParentBBoxes","m","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareNodeMinX","compareNodeMinY","xMargin","_allDistMargin","yMargin","sort","compare","leftBBox","rightBBox","margin","bboxMargin","siblings","indexOf","k","p","destNode","maxX","maxY","arr","n","stack","mid"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/rbush/index.js"],"sourcesContent":["import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}