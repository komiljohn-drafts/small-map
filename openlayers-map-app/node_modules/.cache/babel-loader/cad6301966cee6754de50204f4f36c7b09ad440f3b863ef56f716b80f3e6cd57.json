{"ast":null,"code":"/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport { abstract } from '../util.js';\nconst maxStaleKeys = 5;\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.staleKeys_ = new Array();\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.maxStaleKeys = maxStaleKeys;\n  }\n\n  /**\n   * @return {Array<string>} Get the list of stale keys.\n   */\n  getStaleKeys() {\n    return this.staleKeys_;\n  }\n\n  /**\n   * @param {string} key The new stale key.\n   */\n  prependStaleKey(key) {\n    this.staleKeys_.unshift(key);\n    if (this.staleKeys_.length > this.maxStaleKeys) {\n      this.staleKeys_.length = this.maxStaleKeys;\n    }\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */event.target;\n    if (image.getState() === ImageState.LOADED || image.getState() === ImageState.ERROR) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferred(frameState) {}\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\nexport default LayerRenderer;","map":{"version":3,"names":["EventType","ImageState","Observable","abstract","maxStaleKeys","LayerRenderer","constructor","layer","ready","boundHandleImageChange_","handleImageChange_","bind","layer_","staleKeys_","Array","getStaleKeys","prependStaleKey","key","unshift","length","getFeatures","pixel","getData","prepareFrame","frameState","renderFrame","target","forEachFeatureAtCoordinate","coordinate","hitTolerance","callback","matches","undefined","getLayer","handleFontsChanged","event","image","getState","LOADED","ERROR","renderIfReadyAndVisible","loadImage","imageState","addEventListener","CHANGE","IDLE","load","getVisible","getSourceState","changed","renderDeferred","disposeInternal"],"sources":["/Users/komiljohn/TestTasks/osm-prosight-dev/openlayers-map-app/node_modules/ol/renderer/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport {abstract} from '../util.js';\n\nconst maxStaleKeys = 5;\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.staleKeys_ = new Array();\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.maxStaleKeys = maxStaleKeys;\n  }\n\n  /**\n   * @return {Array<string>} Get the list of stale keys.\n   */\n  getStaleKeys() {\n    return this.staleKeys_;\n  }\n\n  /**\n   * @param {string} key The new stale key.\n   */\n  prependStaleKey(key) {\n    this.staleKeys_.unshift(key);\n    if (this.staleKeys_.length > this.maxStaleKeys) {\n      this.staleKeys_.length = this.maxStaleKeys;\n    }\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement|null} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (\n      image.getState() === ImageState.LOADED ||\n      image.getState() === ImageState.ERROR\n    ) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferred(frameState) {}\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,wBAAwB;AAC9C,OAAOC,UAAU,MAAM,kBAAkB;AACzC,OAAOC,UAAU,MAAM,kBAAkB;AACzC,SAAQC,QAAQ,QAAO,YAAY;AAEnC,MAAMC,YAAY,GAAG,CAAC;;AAEtB;AACA;AACA;AACA,MAAMC,aAAa,SAASH,UAAU,CAAC;EACrC;AACF;AACA;EACEI,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAAC,CAAC;;IAEP;AACJ;AACA;AACA;IACI,IAAI,CAACC,KAAK,GAAG,IAAI;;IAEjB;IACA,IAAI,CAACC,uBAAuB,GAAG,IAAI,CAACC,kBAAkB,CAACC,IAAI,CAAC,IAAI,CAAC;;IAEjE;AACJ;AACA;AACA;IACI,IAAI,CAACC,MAAM,GAAGL,KAAK;;IAEnB;AACJ;AACA;AACA;IACI,IAAI,CAACM,UAAU,GAAG,IAAIC,KAAK,CAAC,CAAC;;IAE7B;AACJ;AACA;AACA;IACI,IAAI,CAACV,YAAY,GAAGA,YAAY;EAClC;;EAEA;AACF;AACA;EACEW,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACF,UAAU;EACxB;;EAEA;AACF;AACA;EACEG,eAAeA,CAACC,GAAG,EAAE;IACnB,IAAI,CAACJ,UAAU,CAACK,OAAO,CAACD,GAAG,CAAC;IAC5B,IAAI,IAAI,CAACJ,UAAU,CAACM,MAAM,GAAG,IAAI,CAACf,YAAY,EAAE;MAC9C,IAAI,CAACS,UAAU,CAACM,MAAM,GAAG,IAAI,CAACf,YAAY;IAC5C;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEgB,WAAWA,CAACC,KAAK,EAAE;IACjB,OAAOlB,QAAQ,CAAC,CAAC;EACnB;;EAEA;AACF;AACA;AACA;EACEmB,OAAOA,CAACD,KAAK,EAAE;IACb,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEE,YAAYA,CAACC,UAAU,EAAE;IACvB,OAAOrB,QAAQ,CAAC,CAAC;EACnB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEsB,WAAWA,CAACD,UAAU,EAAEE,MAAM,EAAE;IAC9B,OAAOvB,QAAQ,CAAC,CAAC;EACnB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEwB,0BAA0BA,CACxBC,UAAU,EACVJ,UAAU,EACVK,YAAY,EACZC,QAAQ,EACRC,OAAO,EACP;IACA,OAAOC,SAAS;EAClB;;EAEA;AACF;AACA;EACEC,QAAQA,CAAA,EAAG;IACT,OAAO,IAAI,CAACrB,MAAM;EACpB;;EAEA;AACF;AACA;AACA;EACEsB,kBAAkBA,CAAA,EAAG,CAAC;;EAEtB;AACF;AACA;AACA;AACA;EACExB,kBAAkBA,CAACyB,KAAK,EAAE;IACxB,MAAMC,KAAK,GAAG,4CAA8CD,KAAK,CAACT,MAAO;IACzE,IACEU,KAAK,CAACC,QAAQ,CAAC,CAAC,KAAKpC,UAAU,CAACqC,MAAM,IACtCF,KAAK,CAACC,QAAQ,CAAC,CAAC,KAAKpC,UAAU,CAACsC,KAAK,EACrC;MACA,IAAI,CAACC,uBAAuB,CAAC,CAAC;IAChC;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,SAASA,CAACL,KAAK,EAAE;IACf,IAAIM,UAAU,GAAGN,KAAK,CAACC,QAAQ,CAAC,CAAC;IACjC,IAAIK,UAAU,IAAIzC,UAAU,CAACqC,MAAM,IAAII,UAAU,IAAIzC,UAAU,CAACsC,KAAK,EAAE;MACrEH,KAAK,CAACO,gBAAgB,CAAC3C,SAAS,CAAC4C,MAAM,EAAE,IAAI,CAACnC,uBAAuB,CAAC;IACxE;IACA,IAAIiC,UAAU,IAAIzC,UAAU,CAAC4C,IAAI,EAAE;MACjCT,KAAK,CAACU,IAAI,CAAC,CAAC;MACZJ,UAAU,GAAGN,KAAK,CAACC,QAAQ,CAAC,CAAC;IAC/B;IACA,OAAOK,UAAU,IAAIzC,UAAU,CAACqC,MAAM;EACxC;;EAEA;AACF;AACA;EACEE,uBAAuBA,CAAA,EAAG;IACxB,MAAMjC,KAAK,GAAG,IAAI,CAAC0B,QAAQ,CAAC,CAAC;IAC7B,IAAI1B,KAAK,IAAIA,KAAK,CAACwC,UAAU,CAAC,CAAC,IAAIxC,KAAK,CAACyC,cAAc,CAAC,CAAC,KAAK,OAAO,EAAE;MACrEzC,KAAK,CAAC0C,OAAO,CAAC,CAAC;IACjB;EACF;;EAEA;AACF;AACA;EACEC,cAAcA,CAAC1B,UAAU,EAAE,CAAC;;EAE5B;AACF;AACA;AACA;EACE2B,eAAeA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACvC,MAAM;IAClB,KAAK,CAACuC,eAAe,CAAC,CAAC;EACzB;AACF;AAEA,eAAe9C,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}